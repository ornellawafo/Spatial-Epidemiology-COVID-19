---
title: "Final Project"
subtitle: "EPIB 677, Winter 2020, McGill University"
author: "Zharmaine Ante, Demy Dam, Ornella Wafo Noubissie" 
date: "`r Sys.Date()`"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r include = FALSE}
## ---- Setup ------------------------------------------------------------------
knitr::opts_chunk$set(
  echo = TRUE,           # show code
  warning = FALSE,       # don't show warnings
  message = FALSE,       # don't show messages (less serious warnings)
  cache = FALSE,         # set to TRUE to save results from last compilation
  fig.align = "center",  # center figures
  fig.asp = 1,           # fig.aspect ratio
  fig.width = 4          # fig width
)
```

# Abstract (1 page)

# Introduction (1 page)

# Analysis Plan (2 pages)

# Descriptive and Univariate Analyses (3 pages)

## Data Cleaning

```{r Load packages, echo = F}
# Data manipulation
library(dplyr)
library(tidyr)

# Creating maps for exploratory analysis
library(spdep)
library(rgdal)
library(maptools)
library(sp)
library(RColorBrewer)
library(classInt)

# Creating graphs
library(ggplot2)
library(gridExtra)
library(ggthemes)
library(pander)

# Models
library(CARBayes)
library(nimble)
```

```{r Hong Kong line list, echo = F, results = F}
# Read in the COVID-19 line list from HK
Linelist <- read.csv("Hong Kong Line List.csv", header = T)

# Create binary variables to prepare for aggregationn
linelist <- Linelist %>%
              mutate(
                Male = ifelse(Gender == "M", 1, 0),
                # Age.0.14 = ifelse(Age >= 0 & Age < 15, 1, 0),
                # Age.15.24 = ifelse(Age >= 15 & Age < 25, 1, 0),
                # Age.25.64 = ifelse(Age >= 25 & Age < 65, 1, 0),
                # Age.65 = ifelse(Age >= 65, 1, 0),
                Cases = 1,
                Deaths = ifelse(Linelist$Outcomes == "Deceased", 1, 0),
                Imported = ifelse(Linelist$Case.classification == "Imported", 1, 0), 
                Resident = ifelse(Linelist$HK.residents == "HK resident", 1, 0), 
                Proxy = ifelse(Linelist$Proxy == "Yes", 1, 0) 
              )

# Rearrange dataframe to prepare for aggregation
linelist <- linelist %>%
              dplyr::select(Case.ID, Region, District, Male, Age, # Age.0.14, Age.15.24, Age.25.64, Age.65,
                     Cases, Deaths, Proxy, Imported, Resident)

# Aggregate dataframe by Region, District, Gender
linelist.agg <- linelist %>%
                  group_by(Region, District) %>%
                  summarise(Cases = sum(Cases),
                            Deaths = sum(Deaths),
                            # P.age.0.14 = sum(Age.0.14)/sum(Cases),
                            # P.age.15.24 = sum(Age.15.24)/sum(Cases),
                            # P.age.25.64 = sum(Age.25.64)/sum(Cases),
                            # P.age.65 = sum(Age.65)/sum(Cases),
                            Age = mean(Age),
                            P.male = sum(Male)/sum(Cases),
                            Proxy = sum(Proxy),
                            Imported = sum(Imported),
                            Resident = sum(Resident))

# Summary of cleaned and aggregated data
summary(linelist.agg)
```

```{r Hong Kong covariates, echo = F, results = F}
# Updated covariates dataset
Covariates <- read.csv("Hong Kong Covariates V2.csv")

# Summary of raw covariates data
summary(Covariates)
cor(Covariates[,3:ncol(Covariates)])

# Absolute covariance values above 0.5
#var.cov <- list()
#for(i in 1:(ncol(data.clean)-1)){
#  var.cov[[i]] <- c(which(abs(cor(data.clean[,2:ncol(data.clean)])[,i]) > 0.7))
#}
#
#names(var.cov) <- paste(names(data.clean[2:ncol(data.clean)])) %>% as.vector()

#Version 1
#Covariates.v1 <- read.csv("Hong Kong Covariates.csv")
#head(Covariates.v1)
#summary(Covariates.v1)
```

```{r Merging datasets, echo = F, results = F}
# Merging the datasets by district
data <- merge(x = linelist.agg, y = Covariates, by = "District")
```

```{r Data manipulation, echo = F, results = F}
## 1) New age categories: 0-24, 25-64, 65+, 
data$Pct_0.24 = data$Pct_0.14 + data$Pct_15.24
data$Prop_0.24 = data$Pct_0.24/100
data$Prop_25.64 = data$Pct_25.64/100
data$Prop_65 = data$Pct_65/100

## 2) Re-calculate population-level variables, based on female and male counts
data$Total_pop = data$Male_count + data$Female_count
data$Pop_density = data$Total_pop/data$Area_km2
data$Prop_labor = data$Count_labor/data$Total_pop
data$Prop_male = data$Male_count/data$Total_pop
data$Prop_female = data$Female_count/data$Total_pop
data$Prop_poor = data$poor_individuals_000s/data$Total_pop
data$Prop_poor_household = data$poor_households/data$Num_household

## 3) Log-transformation of monthly income and education variables
data$Prop_sec = data$Pct_Sec/100
data$Prop_postsec = data$Pct_PostSec/100
data$Log_income = log(data$Monthly_income)
data$Log_sec = log(data$Prop_sec)
data$Log_postsec = log(data$Prop_postsec)

## 4) Calculate expected cases and SIR using standardization method
tot.case = sum(data$Cases)
tot.pop = sum(data$Total_pop)
ave.rate = tot.case/tot.pop
data$Expected = ave.rate*data$Total_pop
data$SIR = data$Cases/data$Expected

## 5) Log transform population density
data$log_pop_density <- log(data$Pop_density)

## 6) Calculate average hospital beds per hospital
data$beds_per_hosp <- with(data, Num_beds/Num_hosp)

## 7) Standardized pop density and post sec
data$st_pop_density <- (data$Pop_density - mean(data$Pop_density))/sd(data$Pop_density)
data$st_post_sec <- (data$Prop_postsec - mean(data$Prop_postsec))/sd(data$Prop_postsec)
hist(data$st_pop_density, breaks = 5)
hist(data$st_post_sec, breaks = 5)
```

```{r Final clean dataset, echo = F, results = F}
# Keep only variables we want to include in spatial analysis
data.clean <- data %>%
  dplyr::select(District,
         Cases,
         Expected,
         SIR,
         st_pop_density,
         Prop_labor,
         beds_per_hosp,
         Prop_0.24,
         Prop_25.64,
         Prop_65,
         Prop_female,
         Log_postsec)

#Mean_median_age,
#household_poverty_rate,
# Prop_female_labor,
# Pop_density,
# log_pop_density,       
# Deaths,
# Mean.age = Age,
# Prop.male = P.male,
# Area_km2,
# Household_size,
# Prop_poor
# Mean_median_age,
# Log_sec,
# Log_postsec)
```

# Exploratory analysis

```{r Summary of clean dataset, echo = F}
# Summary of final cleaned dataset
summary(data.clean)
```

```{r Correlation matrix and pairs plot, echo = F}
# Correlation matrix
cor(subset(data.clean, select = -District))

# Pairs plot
pairs(subset(data.clean, select = -District))
```

```{r Histograms of selected variables, echo = F}
# Full dataset: Select variables and plot histograms ---------------------------------------------
data %>% 
 dplyr::select(Cases, 
               SIR,
               Pop_density,
               # log_pop_density, # Doesn't seemt to improve much
               Pct_0.24, 
               Pct_15.24, 
               Pct_25.64, 
               Pct_65, 
               Log_income, 
               Prop_labor, 
               Prop_male_labor, 
               Num_household,
               Mean_median_age, 
               Log_postsec, 
               Num_hosp, 
               Num_beds,
               beds_per_hosp) %>% 
  gather() %>%                             
  ggplot(aes(value)) +                     
    facet_wrap(~key, scales = "free") +    
    geom_histogram(bins = 5) +
    xlab("") + ylab("Frequency")

# Cleaned dataset: Select variables and plot histograms-------------------------------------------
data.clean %>% 
 dplyr::select(Cases, 
               SIR,
               st_pop_density,
               Prop_labor,
               Prop_female,
               Prop_0.24,
               Prop_25.64,
               Prop_65,
               Log_postsec,
               beds_per_hosp) %>%
  gather() %>%                             
  ggplot(aes(value)) +                     
    facet_wrap(~key, scales = "free") +    
    geom_histogram(bins = 5) +
    xlab("") + ylab("Frequency")
```


## Maps of the outcome and covariates

```{r Data manipulation for mapping, echo = F}
# Coordinates (centroids) by district -----------------------------------------------------------
HKcoords <- read.csv("HK_coords.csv", header = T)
HKcoords <- HKcoords[order(HKcoords$District), ]
data$Lat <- HKcoords$Lat
data$Long <- HKcoords$Long

# Adding variables in shapefile -----------------------------------------------------------------
shp_HK = readOGR("shp_HK/Hong_Kong_18_Districts.shp", stringsAsFactors = FALSE)
shp_HK = shp_HK[order(shp_HK$ENAME),]
shp_HK$Lat = data$Lat
shp_HK$Long = data$Long
shp_HK$Cases = data$Cases
shp_HK$Expected = data$Expected
shp_HK$SIR = data$SIR
shp_HK$Rate = (data$Cases/data$Total_pop)*100000
shp_HK$PopDens = data$Pop_density
shp_HK$PropFemale = data$Prop_female
shp_HK$Prop0_24 = data$Prop_0.24
shp_HK$Prop25_64 = data$Prop_25.64
shp_HK$Prop65 = data$Prop_65
shp_HK$PostSec = data$Prop_postsec
shp_HK$PropLabor = data$Prop_labor
shp_HK$beds_per_hosp = data$beds_per_hosp

#shp_HK$TotalPop = data$Total_pop
#shp_HK$LogPopDens = data$log_pop_density
#shp_HK$PropMale = data$Prop_male
#shp_HK$Income = data$Monthly_income
#shp_HK$Housing = data$Num_household
#shp_HK$Hosp = data$N.Hospital
#shp_HK$HospBeds = data$Num_beds
#shp_HK$SecEduc = data$Prop_sec
#shp_HK$PropMaleLabor = data$Pct.Male.Labor
#shp_HK$PropPoor = data$Prop_poor
#shp_HK$PropPoorHousehold = data$Prop_poor_household


# Converting shapefile data to dataframe object -------------------------------------------------
# Merge the "fortified" data with the data from our spatial object
shp_HK$id = rownames(shp_HK@data)
shp = fortify(shp_HK)
shp_HK.df = merge(shp, shp_HK@data, by = "id")
```

```{r Mapping outcome by district, echo = F}
# Plot of Total COVID-19 cases (as continuous variable) -----------------------------------------
ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Cases)) + 
  ggtitle("Total COVID-19 cases, by district") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of Total COVID-19 cases (as discrete variable) --------------------------------------------
brks <- classIntervals(shp_HK$Cases, n=5, style="quantile")
brks <- brks$brks
shp_HK.df$CasesCat[shp_HK.df$Cases < 10] = 0
shp_HK.df$CasesCat[shp_HK.df$Cases >= 10 & shp_HK.df$Cases < 15] = 1
shp_HK.df$CasesCat[shp_HK.df$Cases >= 15 & shp_HK.df$Cases < 20] = 2
shp_HK.df$CasesCat[shp_HK.df$Cases >= 20 & shp_HK.df$Cases < 43] = 3
shp_HK.df$CasesCat[shp_HK.df$Cases >= 43] = 4
shp_HK.df$CasesCat = factor(shp_HK.df$CasesCat, levels = 0:4, labels = c("<10", "10-14", "15-19", "20-42", ">42"))

plota =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = CasesCat)) + 
  scale_fill_brewer(palette = "YlOrRd") +
  ggtitle("Total COVID-19 cases") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of COVID-19 rate per 100,000 ---------------------------------------------------------------
brks <-classIntervals(shp_HK$Rate, n=5, style="quantile")
brks <- brks$brks
shp_HK.df$RateCat[shp_HK.df$Rate < brks[2]] = 0
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[2] & shp_HK.df$Rate < brks[3]] = 1
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[3] & shp_HK.df$Rate < brks[4]] = 2
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[4] & shp_HK.df$Rate < brks[5]] = 3
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[5]] = 4
shp_HK.df$RateCat = factor(shp_HK.df$RateCat, levels = 0:4, 
                           labels = c("<2.5", "2.5-3.2", "3.2-4.5", "4.5-13.6", ">13.6"))

plota2 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = RateCat)) + 
  scale_fill_brewer(palette = "YlOrRd") +
  ggtitle("Rate of COVID-19 per 100,000") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of SIR ------------------------------------------------------------------------------------
plota3 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = SIR)) + 
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  ggtitle("Standardized Incidence Ratio") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plota, plota2, plota3, ncol = 3)

```

```{r Mapping covariates by district, echo = F}

# Population density, female and HC capacity ######################################################

# Plot of population density ----------------------------------------------------------------------
plot.popdensity = 
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PopDens)) + 
  ggtitle("Population density") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of average number of beds per hospital ----------------------------------------------------
plot.bedshosp =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = beds_per_hosp)) + 
  ggtitle("N of beds per hospital") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of female population ----------------------------------------------------------------------
plot.female = 
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PropFemale)) + 
  ggtitle("Proportion of females") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plot.popdensity, plot.bedshosp, plot.female, ncol = 3)


# Age composition ################################################################################

# Plot of population of 0-24 ---------------------------------------------------------------------
plot.age1 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Prop0_24)) + 
  ggtitle("Proportion of 0-24 years old") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of population of 25-64 years old ----------------------------------------------------------
plot.age2 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Prop25_64)) + 
  ggtitle("Proportion of 25-64 years old") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of population of 65+ ----------------------------------------------------------------------
plot.age3 = 
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Prop65)) + 
  ggtitle("Proportion of 65 and above") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plot.age1, plot.age2, plot.age3, ncol = 3)


# SES ############################################################################################

# Plot of proportion labor ----------------------------------------------------------------------------
plot.labor =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PropLabor)) + 
  ggtitle("Proportion of Pop. in Labor Force") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of proportion of post-sec educ ------------------------------------------------------------
plot.postsec =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PostSec)) + 
  ggtitle("Proportion with Post-Secondary Education") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plot.labor, plot.postsec)
```

## Moran's I statistic spatial autocorrelation test

```{r Building neighborhood structure, echo = F, results = F}
# Build neighborhood object ----------------------------------------------------------------------
coords <- as.matrix(subset(HKcoords, select = c(Long, Lat)))
IDs <- shp_HK$ENAME

# 1) Having contiguous boundary point
HK.nb <- poly2nb(shp_HK, row.names = IDs)
summary(HK.nb)

# 2) Having 3 nearest neighbors
HK.nb3 <- knn2nb(knearneigh(coords, k = 3, longlat = TRUE), row.names = IDs, sym = T)
summary(HK.nb3)

# 3) Having 5 nearest neighbors
HK.nb5 <- knn2nb(knearneigh(coords, k = 5, longlat = TRUE), row.names = IDs, sym = T)
summary(HK.nb5)

# Plot neighbourhood structure -------------------------------------------------------------------
plot(shp_HK, border="grey", main="Contiguous border", cex.main = 0.5)
plot(HK.nb, coords, add=TRUE)

plot(shp_HK, border="grey", main="K = 3 nearest neighbors")
plot(HK.nb3, coords, add=TRUE)

plot(shp_HK, border="grey", main="K = 5 nearest neighbors")
plot(HK.nb5, coords, add=TRUE)

# Convert neighborhood object to weight list -----------------------------------------------------
HK.wnb <-  nb2listw(HK.nb, style = "B", zero.policy = T)
HK.wnb3 <- nb2listw(HK.nb3, style = "B")
HK.wnb5 <- nb2listw(HK.nb5, style = "B")
```

```{r Univariate Poisson models}
# Coding glm regression --------------------------------------------------------------------------
poi.fit1 <- glm(Cases ~ st_pop_density + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit2 <- glm(Cases ~ Prop_female + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit3 <- glm(Cases ~ Prop_0.24 + Prop_25.64 + Prop_65 + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit4 <- glm(Cases ~ Prop_labor + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit5 <- glm(Cases ~ beds_per_hosp + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit6 <- glm(Cases ~ household_poverty_rate + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit7 <- glm(Cases ~ st_pop_density + Prop_female + Prop_0.24 + Prop_25.64 + Prop_65 + 
                Prop_labor + beds_per_hosp + household_poverty_rate + offset(log(Expected)), 
                data = data.clean, family = poisson(link="log"))

# Summaries of regression ------------------------------------------------------------------------
summary(poi.fit1)
summary(poi.fit2)
summary(poi.fit3)
summary(poi.fit4)
summary(poi.fit5)
summary(poi.fit6)
summary(poi.fit7)

# Table of univariate and multivariate comparison ------------------------------------------------
coef.uni <- signif(c(poi.fit1$coefficient[2], poi.fit2$coefficient[2], poi.fit3$coefficient[2],
                    poi.fit3$coefficient[3], poi.fit3$coefficient[4], poi.fit4$coefficient[2],
                    poi.fit5$coefficient[2], poi.fit6$coefficient[2]), 3)
coef.uni.se <- round(c(0.047992, 5.394, 136.9, 136.9, 136.9, 2.353, 0.0002422, -0.16196), 3)
coef.multi <- signif(c(poi.fit7$coefficient[2], poi.fit7$coefficient[3], poi.fit7$coefficient[4],
                      poi.fit7$coefficient[5], poi.fit7$coefficient[6], poi.fit7$coefficient[7],
                      poi.fit7$coefficient[8], poi.fit7$coefficient[9]), 3)
coef.multi.se <- c(9.583e-02, 1.434e+01, 1.720e+02, 1.670e+02, 1.704e+02, 6.470e+00, 1.645e-04, 4.499e-02)
uni.analysis <- data.frame("Univariate estimate" = coef.uni, "SE" = coef.uni.se,
                           "Multivariate estimate" = coef.multi, "SE" = coef.multi.se)
```

```{r Morans test, echo = F, results = T}
# Moran test for SIR -----------------------------------------------------------------------------
moran.sir1 <- moran.test(data$SIR, HK.wnb, zero.policy = T)
moran.sir2 <- moran.test(data$SIR, HK.wnb3, zero.policy = T)
moran.sir3 <- moran.test(data$SIR, HK.wnb5, zero.policy = T)

# Moran test for glm residuals -------------------------------------------------------------------
moran.lm1 <- lm.morantest(poi.fit1, HK.wnb, zero.policy = T)
moran.lm2 <- lm.morantest(poi.fit2, HK.wnb, zero.policy = T)
moran.lm3 <- lm.morantest(poi.fit3, HK.wnb, zero.policy = T)
moran.lm4 <- lm.morantest(poi.fit4, HK.wnb, zero.policy = T)
moran.lm5 <- lm.morantest(poi.fit5, HK.wnb, zero.policy = T)
moran.lm6 <- lm.morantest(poi.fit6, HK.wnb, zero.policy = T)
moran.lm7 <- lm.morantest(poi.fit7, HK.wnb, zero.policy = T)

# Moran's test results ---------------------------------------------------------------------------

# I statistic
I.1 <-  round(as.numeric(moran.sir1$estimate[1]), 4)
I.2 <-  round(as.numeric(moran.sir2$estimate[1]), 4)
I.3 <-  round(as.numeric(moran.sir3$estimate[1]), 4)
I.4 <-  round(as.numeric(moran.lm1$estimate[1]), 4)
I.5 <-  round(as.numeric(moran.lm2$estimate[1]), 4)
I.6 <-  round(as.numeric(moran.lm3$estimate[1]), 4)
I.7 <-  round(as.numeric(moran.lm4$estimate[1]), 4)
I.8 <-  round(as.numeric(moran.lm5$estimate[1]), 4)
I.9 <-  round(as.numeric(moran.lm6$estimate[1]), 4)
I.10 <- round(as.numeric(moran.lm7$estimate[1]), 4)

# Expectation
E.1 <- round(as.numeric(moran.sir1$estimate[2]), 4)
E.2 <- round(as.numeric(moran.sir2$estimate[2]), 4)
E.3 <- round(as.numeric(moran.sir3$estimate[2]), 4)
E.4 <-  round(as.numeric(moran.lm1$estimate[2]), 4)
E.5 <-  round(as.numeric(moran.lm2$estimate[2]), 4)
E.6 <-  round(as.numeric(moran.lm3$estimate[2]), 4)
E.7 <-  round(as.numeric(moran.lm4$estimate[2]), 4)
E.8 <-  round(as.numeric(moran.lm5$estimate[2]), 4)
E.9 <-  round(as.numeric(moran.lm6$estimate[2]), 4)
E.10 <- round(as.numeric(moran.lm7$estimate[2]), 4)

# Variance
V.1 <- round(as.numeric(moran.sir1$estimate[3]), 4)
V.2 <- round(as.numeric(moran.sir2$estimate[3]), 4)
V.3 <- round(as.numeric(moran.sir3$estimate[3]), 4)
V.4 <-  round(as.numeric(moran.lm1$estimate[3]), 4)
V.5 <-  round(as.numeric(moran.lm2$estimate[3]), 4)
V.6 <-  round(as.numeric(moran.lm3$estimate[3]), 4)
V.7 <-  round(as.numeric(moran.lm4$estimate[3]), 4)
V.8 <-  round(as.numeric(moran.lm5$estimate[3]), 4)
V.9 <-  round(as.numeric(moran.lm6$estimate[3]), 4)
V.10 <- round(as.numeric(moran.lm7$estimate[3]), 4)

# Standard deviate
sd.1 <- signif(as.numeric(moran.sir1$statistic), 4)
sd.2 <- signif(as.numeric(moran.sir2$statistic), 4)
sd.3 <- signif(as.numeric(moran.sir3$statistic), 4)
sd.4 <- signif(as.numeric(moran.lm1$statistic), 4)
sd.5 <- signif(as.numeric(moran.lm2$statistic), 4)
sd.6 <- signif(as.numeric(moran.lm3$statistic), 4)
sd.7 <- signif(as.numeric(moran.lm4$statistic), 4)
sd.8 <- signif(as.numeric(moran.lm5$statistic), 4)
sd.9 <- signif(as.numeric(moran.lm6$statistic), 4)
sd.10 <-signif(as.numeric(moran.lm7$statistic), 4)

# P-value
p.1 <- signif(as.numeric(moran.sir1$p.value), 4)
p.2 <- signif(as.numeric(moran.sir2$p.value), 4)
p.3 <- signif(as.numeric(moran.sir3$p.value), 4)
p.4 <- signif(as.numeric(moran.lm1$p.value), 4)
p.5 <- signif(as.numeric(moran.lm2$p.value), 4)
p.6 <- signif(as.numeric(moran.lm3$p.value), 4)
p.7 <- signif(as.numeric(moran.lm4$p.value), 4)
p.8 <- signif(as.numeric(moran.lm5$p.value), 4)
p.9 <- signif(as.numeric(moran.lm6$p.value), 4)
p.10 <-signif(as.numeric(moran.lm7$p.value), 4)

# Table of Moran's test results -------------------------------------------------------------------
moran.tests <- c("SIR (adjacency-based)", "SIR (distance-based k = 3)", "SIR (distance-based k = 5",
                 "Y ~ st_pop_density", "Y ~ Prop_female", "Y ~ Prop_0.24 + Prop_25.64 + Prop_65", 
                 "Y ~ Prop_labor", "Y ~ beds_per_hosp", "Y ~ household_poverty_rate", "Y ~ .")
coef.I <- c(I.1, I.2, I.3, I.4, I.5, I.6, I.7, I.8, I.9, I.10)
coef.E <- c(E.1, E.2, E.3, E.4, E.5, E.6, E.7, E.8, E.9, E.10)
coef.V <- c(V.1, V.2, V.3, V.4, V.5, V.6, V.7, V.8, V.9, V.10)
coef.sd <- c(sd.1, sd.2, sd.3, sd.4, sd.5, sd.6, sd.7, sd.8, sd.9, sd.10)
coef.p <- c(p.1, p.2, p.3, p.4, p.5, p.6, p.7, p.8, p.9, p.10)
moran.results <- data.frame("Model" = moran.tests, "I" = coef.I, "E(I)" = coef.E,
                            "Var(I)" = coef.V, "Std deviate" = coef.sd, "P value" = coef.p)

```

## Poisson Model

```{r Poisson Model, echo = F}
# Poisson regression -------------------------------------------------------------------------
poi.fit <- glm(Cases ~ . - District - SIR - Expected + offset(log(Expected)), 
               data = data.clean, family = poisson(link = "log"))
summary(poi.fit)

# Checking assumption of a Poisson model -----------------------------------------------------
par(mfrow = c(1,2))
hist(poi.fit$residuals, main="COVID-19", xlab = "Raw residuals") # a bit skewed to the right
abline(v = 0, lty = 2, col = "red")

plot(rstandard(poi.fit), ylab = "standardized residuals") #some overdispersed residuals
abline(h = 0, lty = 2, col = "red")
par(mfrow = c(1,1))

# Overdispersion ----------------------------------------------------------------------------
library(AER); library(car)
dispersiontest(poi.fit, alternative = "greater") 
# Based from the test, there is overdispersion 
# (indicates residual risk even after adjusting for the covariates)

# Checking for model fit (obs vs fitted) ---------------------------------------------------------
plot(x = poi.fit$fitted.values, y = data.clean$Cases, 
     bty="n", xlab="Fitted", ylab="Observed", main = "COVID-19")
abline(a=0,b=1,lwd=2)
```


# Spatial Models

## Building neighbors and adjacency list

```{r Building neighbors and adjacency list for Nimble, echo = F}
# Converting neighborhood objects to matrix -----------------------------------------

# 1) Having contiguous boundary point
HK.nbmat.adj <- nb2mat(HK.nb, style = 'B', zero.policy = TRUE) 

# 2) Having 3 nearest neighbors
HK.nbmat.3 <- nb2mat(HK.nb3, style = 'B', zero.policy = TRUE) 

# 3) Having 5 nearest neighbors
HK.nbmat.5 <- nb2mat(HK.nb5, style = 'B', zero.policy = TRUE) 

# Number of neighbors per district --------------------------------------------------
n <- nrow(data.clean)

# 1) Having contiguous boundary point
num.nb <- rowSums(HK.nbmat.adj)

# 2) Having 3 nearest neighbors
num.nb.3 <- rowSums(HK.nbmat.3)

# 3) Having 5 nearest neighbors
num.nb.5 <- rowSums(HK.nbmat.5)

# Adjacency vectors -----------------------------------------------------------------

# 1) Having contiguous boundary point
adj <- c()
adj <- which(HK.nbmat.adj[1,] == 1)
for(i in 2:n){
  adj <- c(adj, c(which(HK.nbmat.adj[i,] == 1)))
}

# 2) Having 3 nearest neighbors 
adj.3 <- list()
for(i in 1:n){
  adj.3[[i]] <- c(which(HK.nbmat.3[i,] == 1))
}
adj.3 <- unlist(adj.3)

#3) Having 5 nearest neighbors 
adj.5 <- list()
for(i in 1:n){
  adj.5[[i]] <- c(which(HK.nbmat.5[i,] == 1))
}
adj.5 <- unlist(adj.5)
```

## Nimble Regression: iCAR with usual fixed priors

```{r Nimble: iCAR Usual fixed priors model, echo = F}

set.seed(1234)

# Defining the usual fixed priors model ------------------------------------------------------
usual_code <- nimbleCode({
  
  # Defining our priors
  beta0 ~ dnorm(0, sd = 100)
  for(j in 1:p){
    beta[j] ~ dnorm(0, sd = 100)  #Betas for the covariates
  }
  sigma2 ~ dinvgamma(1, 0.01)

  #sigma2 ~ dinvgamma(1, 10) 
  # tau2 ~ dinvgamma(2, 0.10) 
  #here i set up a prior for tau directly, it makes the MCMC converge better
  
  # Defining transformed parameters
  tau2 <- 1/sigma2
  s[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau2, zero_mean = 1) #CAR prior
  # Spatial effects (dcar is long vector, weights, n neighbors, zero mean = 1 constrains sum to 0)

  # Defining likelihood 
  for(i in 1:N) { 
    log(r[i]) <- beta0 + inprod(X[i, 1:p], beta[1:p]) + s[i]
    mu[i] <- E[i]*r[i] 
    y[i] ~ dpois(mu[i]) 
  } 
})
```

**Neighborhood structure 1: Adjacency-based neighbors**

```{r iCAR Adjacency-based Model, echo = F, results = F, message = F}
# Defining the data that goes into the model -----------------------------------------------------
# (1) Define constants that go into CAR prior into a list
Consts_usual_01 = list(N = nrow(data.clean),                      # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),  # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),# Matrix of covariates
                       L = length(adj),                       # Edges (length of adj vector)
                       E = data.clean$Expected,               # Expected cases
                       adj = adj,                             # Adjacency matrix
                       num = num.nb,                          # Number of neighbors per district
                       weights = rep(1, length(adj)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual <- list(beta0 = 0,
                    beta = rep(0, ncol(data.clean[, 5:ncol(data.clean)])), 
                    sigma2 = 1, 
                    #tau2 = 0.1,
                    s = rnorm(length(num.nb)))

# Defining model -------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
usual01_model <- nimbleModel(code = usual_code, constants = Consts_usual_01, data = outcome, inits = Inits_usual)

# (2) Define the compiled nimble model
usual01_Cmodel <- compileNimble(usual01_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
usual01_conf <- configureMCMC(usual01_model, monitors = c('beta0', 'beta', 'sigma2', 's'))

# (4) Print samplers
usual01_conf$printSamplers()

# (5) Build MCMC object
usual01_MCMC <- buildMCMC(usual01_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
usual01_CMCMC <- compileNimble(usual01_MCMC, project = usual01_Cmodel)  

# (7) Run the model
usual01_runMCMC <- runMCMC(usual01_CMCMC, niter = 200000, nburnin = 15000, thin = 20, nchains = 2, WAIC = T)

# (8) Check convergence
usual01_samples = rbind(usual01_runMCMC$samples[[1]], usual01_runMCMC$samples[[2]])

```

```{r iCAR Adjacency-based Model  Summaries}

# (9) WAIC ---------------------------------------------------------------------------------------
usual01_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta 0 

# Calculating the beta0 means
mean_beta0_usual01 <- mean(usual01_samples[ ,7])

# Calculating the Beta 95% CrI 
CrI_beta0_usual_01 <- t(quantile(usual01_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_01 <- cbind(mean_beta0_usual01, CrI_beta0_usual_01) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_usual_01)

################## Covariate Estimates: Beta

# Calculating the Beta means
means_betas_usual_01 <- apply(usual01_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_usual_01 <- t(apply(usual01_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_01 <- t(matrix(c(means_betas_usual_01, CrI_betas_usual_01), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_01)

################### Spatial effect per region: S

# Calculating the S means
means_s_usual_01 <- apply(usual01_samples[ ,8:(ncol(usual01_samples)-1)],2, mean)

# Calculating the S 95% CrI 
CrI_s_usual_01 <- t(apply(usual01_samples[ ,8:(ncol(usual01_samples)-1)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_01 <- cbind(means_s_usual_01, CrI_s_usual_01) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_01)


```

```{r iCAR Adjacency-based Model  Fitted Values}

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_usual01 = matrix(NA, nrow=nrow(usual01_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_usual01[,i] = usual01_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%  t(usual01_samples[,1:8]) + usual01_samples[, s[i]] 

}

# Mean fitted SIR
fitted_SIR_usual01 <- exp(apply(fitted_usual01, 2, mean))

# Mean fitted Cases
fitted_usual01_cases <- fitted_SIR_usual01*data.clean$Expected

# 95% CrI SIR
fitted_usual01_CrI_SIR <- t(exp(apply(fitted_usual01, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_usual01_CrI <-  data.clean$Expected *fitted_usual01_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_usual01_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_usual01,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_usual01_cases), 
                                "CrI LL"    =  round(fitted_usual01_CrI[,1]),
                                "CrI UL"    =  round(fitted_usual01_CrI[,2]))


# Top 6 rows
head(fitted_usual01_df)

```

```{r iCAR Adjacency-based Model  MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", usual01_samples[,"beta0"], type ="l")

# betas (covariates) - log scale
par(mfrow=c(4,2), mar=c(3, 3, 3, 2) + 0.1)
plot(main = paste(names(data.clean[5])),  usual01_samples[,"beta[1]"] , type = "l", ylab = "") 
plot(main = paste(names(data.clean[6])),  usual01_samples[,"beta[2]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[7])),  usual01_samples[,"beta[3]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[8])),  usual01_samples[,"beta[4]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[9])),  usual01_samples[,"beta[5]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[10])), usual01_samples[,"beta[6]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[11])), usual01_samples[,"beta[7]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[12])), usual01_samples[,"beta[8]"] , type = "l", ylab = "")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", usual01_samples[,"sigma2"], type = "l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), usual01_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), usual01_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), usual01_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), usual01_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), usual01_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), usual01_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), usual01_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), usual01_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), usual01_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), usual01_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), usual01_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), usual01_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), usual01_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), usual01_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), usual01_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), usual01_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), usual01_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), usual01_samples[,"s[18]"], type = "l")
```

```{r iCAR Adjacency-based Model  Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(usual01_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(usual01_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(usual01_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(usual01_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(usual01_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(usual01_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(usual01_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(usual01_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(usual01_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(usual01_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(usual01_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(usual01_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(usual01_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(usual01_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(usual01_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(usual01_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(usual01_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(usual01_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(usual01_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(usual01_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(usual01_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(usual01_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(usual01_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(usual01_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(usual01_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(usual01_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(usual01_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(usual01_samples[,"s[18]"]))
```

**Neighborhood structure 2: Distance-based neighbors (k = 3)**

```{r iCAR K = 3  Model, echo = F, results = F, message = F}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_02 = list(N = nrow(data.clean),                    # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.3),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.3,                             # Adjacency matrix
                       num = num.nb.3,                          # Number of neighbors per district
                       weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_02 <- list(beta0 = 0,
                    beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                    sigma2 = 1, 
                    s = rnorm(nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
usual02_model <- nimbleModel(code = usual_code, constants = Consts_usual_02, data = outcome, inits = Inits_usual_02)

# (2) Define the compiled nimble model
usual02_Cmodel <- compileNimble(usual02_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
usual02_conf <- configureMCMC(usual02_model, monitors = c('beta0', 'beta', 'sigma2', 's'))

# (4) Print samplers
usual02_conf$printSamplers()

# (5) Build MCMC object
usual02_MCMC <- buildMCMC(usual02_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
usual02_CMCMC <- compileNimble(usual02_MCMC, project = usual02_Cmodel)  

# (7) Run the model
usual02_runMCMC <- runMCMC(usual02_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
usual02_samples = rbind(usual02_runMCMC$samples[[1]], usual02_runMCMC$samples[[2]])
```

```{r iCAR K = 3  Summaries}

# (9) WAIC ---------------------------------------------------------------------------------------
usual02_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta0 

# Calculating the beta0 means
mean_beta0_usual02 <- mean(usual02_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_usual_02 <- t(quantile(usual02_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_02 <- cbind(mean_beta0_usual02, CrI_beta0_usual_02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_usual_02)


################## Covariate Estimates: Beta

# Calculating the Beta means
means_betas_usual_02=apply(usual02_samples[,1:8],2, mean)


# Calculating the Beta 95% CrI 
CrI_betas_usual_02=t(apply(usual02_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_02 <- t(matrix(c(means_betas_usual_02, CrI_betas_usual_02), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_02)

################### Spatial effect per region: S

# Calculating the S means
means_s_usual_02 <- apply(usual02_samples[ ,8:(ncol(usual02_samples)-1)],2, mean)

# Calculating the S 95% CrI 
CrI_s_usual_02 <- t(apply(usual02_samples[ ,8:(ncol(usual02_samples)-1)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_02 <- cbind(means_s_usual_02, CrI_s_usual_02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_02)

```

```{r iCAR K = 3  Fitted Values }

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_usual02 = matrix(NA, nrow=nrow(usual02_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_usual02[,i] = usual02_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%  t(usual02_samples[,1:8]) + usual02_samples[, s[i]] 
}



# Mean fitted SIR
fitted_SIR_usual02 <- exp(apply(fitted_usual02, 2, mean))

# 95% CrI SIR
fitted_usual02_CrI_SIR <- t(exp(apply(fitted_usual02, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# Mean fitted Cases
fitted_usual02_cases <- fitted_SIR_usual02*data.clean$Expected


# 95% CrI Cases
fitted_usual02_CrI <-  data.clean$Expected *fitted_usual02_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_usual02_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_usual02,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_usual02_cases), 
                                "CrI LL"    =  round(fitted_usual02_CrI[,1]),
                                "CrI UL"    =  round(fitted_usual02_CrI[,2]))


# Top 6 rows
head(fitted_usual02_df)

 
```

```{r iCAR K = 3  MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", usual02_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  usual02_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  usual02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  usual02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  usual02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  usual02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), usual02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), usual02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), usual02_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", usual02_samples[,"sigma2"], type = "l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), usual02_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), usual02_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), usual02_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), usual02_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), usual02_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), usual02_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), usual02_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), usual02_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), usual02_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), usual02_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), usual02_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), usual02_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), usual02_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), usual02_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), usual02_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), usual02_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), usual02_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), usual02_samples[,"s[18]"], type = "l")
```

```{r iCAR K = 3  Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(usual02_samples[,"beta0"]))

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(usual02_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(usual02_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(usual02_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(usual02_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(usual02_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(usual02_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(usual02_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(usual02_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(usual02_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(usual02_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(usual02_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(usual02_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(usual02_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(usual02_samples[,"beta[14]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(usual02_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(usual02_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(usual02_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(usual02_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(usual02_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(usual02_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(usual02_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(usual02_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(usual02_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(usual02_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(usual02_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(usual02_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(usual02_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(usual02_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(usual02_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(usual02_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(usual02_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(usual02_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(usual02_samples[,"s[18]"]))
```

**Neighborhood structure 3: Distance-based neighbors (k = 5)**

```{r iCAR K = 5  Model, echo = F, results = F, message = F}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_03 = list(N = nrow(data.clean),                    # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.5),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.5,                             # Adjacency matrix
                       num = num.nb.5,                          # Number of neighbors per district
                       weights = rep(1, length(adj.5)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_03 <- list(beta0 = 0,
                    beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                    sigma2 = 1, 
                    s = rnorm(nrow(data.clean))) 

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
usual03_model <- nimbleModel(code = usual_code, constants = Consts_usual_03, data = outcome, inits = Inits_usual_03)

# (2) Define the compiled nimble model
usual03_Cmodel <- compileNimble(usual03_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
usual03_conf <- configureMCMC(usual03_model, monitors = c('beta0', 'beta', 'sigma2', 's'))

# (4) Print samplers
usual03_conf$printSamplers()

# (5) Build MCMC object
usual03_MCMC <- buildMCMC(usual03_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
usual03_CMCMC <- compileNimble(usual03_MCMC, project = usual03_Cmodel)  

# (7) Run the model
usual03_runMCMC <- runMCMC(usual03_CMCMC, nburnin = 50000, niter = 200000, nchains = 2, thin = 5, WAIC = T)

# (8) Check convergence
usual03_samples = rbind(usual03_runMCMC$samples[[1]], usual03_runMCMC$samples[[2]])

```

```{r iCAR K = 5  Summaries}

# (9) WAIC ---------------------------------------------------------------------------------------
usual03_runMCMC$WAIC


# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta0 

# Calculating the beta0 means
mean_beta0_usual03 <- mean(usual03_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_usual_03 <- t(quantile(usual03_samples[ ,7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_03 <- cbind(mean_beta0_usual03, CrI_beta0_usual_03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale

exp(mean_CrI_beta0_usual_03)

################## Covariate Estimates: Beta


# Calculating the Beta means
means_betas_usual_03=apply(usual03_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_usual_03=t(apply(usual03_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_03 <- t(matrix(c(means_betas_usual_03, CrI_betas_usual_03), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_03)

################### Spatial effect per region: S

# Calculating the S means
means_s_usual_03 <- apply(usual03_samples[ ,8:(ncol(usual03_samples)-1)],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_usual_03 <- t(apply(usual03_samples[ ,8:(ncol(usual03_samples)-1)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_03 <- cbind(means_s_usual_03, CrI_s_usual_03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_03)


```

```{r iCAR K = 5  Fitted Values}

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_usual03 = matrix(NA, nrow=nrow(usual03_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_usual03[,i] = usual03_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%  t(usual03_samples[,1:8]) + usual03_samples[, s[i]] 
}

# Mean fitted SIR
fitted_SIR_usual03 <- exp(apply(fitted_usual03, 2, mean))

# 95% CrI SIR
fitted_usual03_CrI_SIR <- t(exp(apply(fitted_usual03, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# Mean fitted Cases
fitted_usual03_cases <- fitted_SIR_usual03*data.clean$Expected

# 95% CrI Cases
fitted_usual03_CrI <-  data.clean$Expected *fitted_usual03_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_usual03_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_usual03,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_usual03_cases), 
                                "CrI LL"    =  round(fitted_usual03_CrI[,1]),
                                "CrI UL"    =  round(fitted_usual03_CrI[,2]))


# Top 6 rows
head(fitted_usual03_df)

```

```{r iCAR K = 5  MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", usual03_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  usual03_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  usual03_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  usual03_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  usual03_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  usual03_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), usual03_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), usual03_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), usual03_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", usual03_samples[,"sigma2"], type = "l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), usual03_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), usual03_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), usual03_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), usual03_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), usual03_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), usual03_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), usual03_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), usual03_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), usual03_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), usual03_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), usual03_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), usual03_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), usual03_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), usual03_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), usual03_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), usual03_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), usual03_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), usual03_samples[,"s[18]"], type = "l")
```

```{r iCAR K = 5  Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(usual03_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(usual03_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(usual03_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(usual03_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(usual03_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(usual03_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(usual03_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(usual03_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(usual03_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(usual03_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(usual03_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(usual03_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(usual03_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(usual03_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(usual03_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(usual03_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(usual03_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(usual03_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(usual03_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(usual03_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(usual03_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(usual03_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(usual03_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(usual03_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(usual03_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(usual03_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(usual03_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(usual03_samples[,"s[18]"]))
```

## Nimble Regression: BYM CAR

**Nimble: BYMCAR Usual fixed priors model**

```{r Nimble BYM: Usual fixed priors model, echo = F}
set.seed(1234)
# Defining the usual fixed priors model ------------------------------------------------------
usual_code_bym <- nimbleCode({ 

  # Defining our priors
  beta0 ~ dnorm(0, sd = 100)
  for(j in 1:p){
    beta[j] ~ dnorm(0, sd = 100)  # Betas for the covariates
  }
  sigma2 ~ dinvgamma(1, 0.01)     # Good b/c full conditional is IG --> makes MCMC easier

  # Defining transformed parameters
  # tauv ~ dinvgamma(1, 0.01) 
  tau2 <- 1/sigma2
  s[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau2, zero_mean = 1) # CAR prior

  # Defining likelihood
  for(i in 1:N) { # inprod (beta1X + beta 2X)?
    log(r[i]) <- beta0+ inprod(X[i, 1:p], beta[1:p]) + s[i] + v[i] 
        mu[i] <- r[i]*E[i]
        
        y[i]  ~ dpois(mu[i]) 
        v[i]  ~ dnorm(0,100) 
  }
})
```

**Neighborhood structure 1: Adjacency-based neighbors**

```{r  BYM Adjacency-based, echo = F, results = F, message = F}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_bym_01 = list(N = nrow(data.clean),              # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj),                       # Edges (length of adj vector)
                       E = data.clean$Expected,               # Expected cases
                       adj = adj,                             # Adjacency matrix
                       num = num.nb,                          # Number of neighbors per district
                       weights = rep(1, length(adj)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_bym_01 <- list(beta0 = 0,
                           beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                           sigma2 = 1, 
                           s = rnorm(nrow(data.clean)),
                           v =  rep(0, nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
bym_usual01_model <- nimbleModel(code = usual_code_bym, constants = Consts_usual_bym_01, 
                             data = outcome, inits = Inits_usual_bym_01)

# (2) Define the compiled nimble model
bym_usual01_Cmodel <- compileNimble(bym_usual01_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
bym_usual01_conf <- configureMCMC(bym_usual01_model, monitors = c('beta0', 'beta', 'sigma2', 's', 'v'))

# (4) Do something
bym_usual01_conf$printSamplers()

# (5) Build MCMC object
bym_usual01_MCMC <- buildMCMC(bym_usual01_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
bym_usual01_CMCMC <- compileNimble(bym_usual01_MCMC, project = bym_usual01_Cmodel)  

# (7) Run the model
bym_usual01_runMCMC <- runMCMC(bym_usual01_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
bym_usual01_samples = rbind(bym_usual01_runMCMC$samples[[1]], bym_usual01_runMCMC$samples[[2]])

```

```{r BYM Adjacency-based Summaries}

# (9) WAIC ---------------------------------------------------------------------------------------
bym_usual01_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta 0 

# Calculating the beta0 means
mean_beta0_bym_usual01 <- mean(bym_usual01_samples[ , "beta0"])

# Calculating the Beta 95% CrI 
CrI_beta0_bym_usual01 <- t(quantile(bym_usual01_samples[ , "beta0"], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_bym_usual01 <- cbind(mean_beta0_bym_usual01, CrI_beta0_bym_usual01) %>% as.data.frame()


# Renaming the columns
colnames(mean_CrI_beta0_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_bym_usual01)


################## Covariate Estimates: Beta

# Calculating the Beta means
means_betas_bym_usual01 <- apply(bym_usual01_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual01 <- t(apply(bym_usual01_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual01 <- t(matrix(c(means_betas_bym_usual01, CrI_betas_bym_usual01), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_bym_usual01)

################### Spatial effect per region: S

# Calculating the S means
means_s_bym_usual01 <- apply(bym_usual01_samples[ ,10:27],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_bym_usual01 <- t(apply(bym_usual01_samples[ ,10:27],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_bym_usual01 <- cbind(means_s_bym_usual01, CrI_s_bym_usual01) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_bym_usual01)

################### V : estimates per region

# Calculating the V means
means_v_bym_usual01 <- apply(bym_usual01_samples[ ,29:ncol(bym_usual01_samples)],2, mean)

# Calculating the V 95% CrI 
CrI_v_bym_usual01 <- t(apply(bym_usual01_samples[ ,29:ncol(bym_usual01_samples)],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_v_bym_usual01 <- cbind(means_v_bym_usual01, CrI_v_bym_usual01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_v_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")



```

```{r BYM Adjacency-based  Fitted Values}

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_bym_usual01 = matrix(NA, nrow=nrow(bym_usual01_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_bym_usual01[,i] = bym_usual01_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%  t(bym_usual01_samples[,1:8]) + bym_usual01_samples[, s[i]] + bym_usual01_samples[, v[i]] 
}


# Mean fitted SIR
fitted_SIR_bym_usual01 <- exp(apply(fitted_bym_usual01, 2, mean))

# 95% CrI SIR
fitted_bym_usual01_CrI_SIR <- t(exp(apply(fitted_bym_usual01, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# Mean fitted Cases
fitted_bym_usual01_cases <- fitted_SIR_bym_usual01 *data.clean$Expected

# 95% CrI Cases
fitted_bym_usual01_CrI <-  fitted_bym_usual01_CrI_SIR *data.clean$Expected 

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_bym_usual01_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_bym_usual01,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_bym_usual01_cases), 
                                "CrI LL"    =  round(fitted_bym_usual01_CrI[,1]),
                                "CrI UL"    =  round(fitted_bym_usual01_CrI[,2]))


# Top 6 rows
head(fitted_bym_usual01_df)

```

```{r BYM Adjacency-based MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", bym_usual01_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual01_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual01_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual01_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual01_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual01_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual01_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual01_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual01_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual01_samples[,"sigma2"], type ="l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual01_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual01_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual01_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual01_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual01_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual01_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual01_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual01_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual01_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual01_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual01_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual01_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual01_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual01_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual01_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual01_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual01_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual01_samples[,"s[18]"], type = "l")
```

```{r BYM Adjacency-based Posterior density curve, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual01_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual01_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual01_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual01_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual01_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual01_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual01_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual01_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual01_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual01_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual01_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual01_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual01_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual01_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual01_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual01_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual01_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual01_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual01_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual01_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual01_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual01_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual01_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual01_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual01_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual01_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual01_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual01_samples[,"s[18]"]))
```

**Neighborhood structure 2: Distance-based neighbors (k = 3)**

```{r BYM K = 3 Model, echo = F, results = F, message = F}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_bym_02 = list(N = nrow(data.clean),                # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.3),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.3,                             # Adjacency matrix
                       num = num.nb.3,                          # Number of neighbors per district
                       weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_bym_02 <- list(beta0 = 0,
                           beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                           sigma2 = 1, 
                           s = rnorm(nrow(data.clean)),
                           v =  rep(0, nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
bym_usual02_model <- nimbleModel(code = usual_code_bym, constants = Consts_usual_bym_02, 
                                 data = outcome, inits = Inits_usual_bym_02)

# (2) Define the compiled nimble model
bym_usual02_Cmodel <- compileNimble(bym_usual02_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
bym_usual02_conf <- configureMCMC(bym_usual02_model, monitors = c('beta0', 'beta', 'sigma2', 's', 'v'))

# (4) Print samplers
bym_usual02_conf$printSamplers()

# (5) Build MCMC object
bym_usual02_MCMC <- buildMCMC(bym_usual02_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
bym_usual02_CMCMC <- compileNimble(bym_usual02_MCMC, project = bym_usual02_Cmodel)  

# (7) Run the model
bym_usual02_runMCMC <- runMCMC(bym_usual02_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
bym_usual02_samples = rbind(bym_usual02_runMCMC$samples[[1]], bym_usual02_runMCMC$samples[[2]])


```

```{r BYM K = 3  Summaries}

# (9) WAIC --------------------------------------------------------------------------------------
bym_usual02_runMCMC$WAIC


# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta 0 

# Calculating the beta0 mean
mean_beta0_bym_usual02 <- mean(bym_usual02_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_bym_usual02 <- t(quantile(bym_usual02_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_bym_usual02 <- cbind(mean_beta0_bym_usual02, CrI_beta0_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_bym_usual02)

################## Covariate Estimates: Beta

# Calculating the Beta means
means_betas_bym_usual02 <- apply(bym_usual02_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual02 <- t(apply(bym_usual02_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual02 <- t(matrix(c(means_betas_bym_usual02, CrI_betas_bym_usual02), ncol=8, byrow=T)) %>% as.data.frame()


# Renaming the columns
colnames(mean_CrI_betas_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_bym_usual02)

################### Spatial effect per region: S

# Calculating the S means
means_s_bym_usual02 <- apply(bym_usual02_samples[ , 10:27],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_bym_usual02 <- t(apply(bym_usual02_samples[ , 10:27],2, function(x) quantile(x, probs=c(0.025,0.975))))


# Combining the means and CIs into a dataframe
mean_CrI_s_bym_usual02 <- cbind(means_s_bym_usual02, CrI_s_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_bym_usual02)

################### V : estimates? per region

# Calculating the V means
means_v_bym_usual02 <- apply(bym_usual02_samples[ ,29:ncol(bym_usual02_samples)],2, mean)

# Calculating the V 95% CrI 
CrI_v_bym_usual02 <- t(apply(bym_usual02_samples[ ,29:ncol(bym_usual02_samples)],2, function(x) quantile(x, probs=c(0.025,0.975))))


# Combining the means and CIs into a dataframe
mean_CrI_v_bym_usual02 <- cbind(means_v_bym_usual02, CrI_v_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_v_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_bym_usual02)



```

```{r BYM K = 3 Fitted Values}
# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_bym_usual02 = matrix(NA, nrow=nrow(bym_usual02_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_bym_usual02[,i] = bym_usual02_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(bym_usual02_samples[,1:8]) + bym_usual02_samples[, s[i]] + bym_usual02_samples[, v[i]] 
}


# Mean fitted SIR
fitted_SIR_bym_usual02 <- exp(apply(fitted_bym_usual02, 2, mean))

# 95% CrI SIR
fitted_bym_usual02_CrI_SIR <- t(exp(apply(fitted_bym_usual02, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# Mean fitted Cases
fitted_bym_usual02_cases <- fitted_SIR_bym_usual02 *data.clean$Expected

# 95% CrI Cases
fitted_bym_usual02_CrI <-  fitted_bym_usual02_CrI_SIR *data.clean$Expected 

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_bym_usual02_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_bym_usual02,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_bym_usual02_cases), 
                                "CrI LL"    =  round(fitted_bym_usual02_CrI[,1]),
                                "CrI UL"    =  round(fitted_bym_usual02_CrI[,2]))


# Top 6 rows
head(fitted_bym_usual02_df)

```

```{r BYM K = 3 MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", bym_usual02_samples[,"beta0"], type = "l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual02_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual02_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual02_samples[,"sigma2"], type ="l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual02_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual02_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual02_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual02_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual02_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual02_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual02_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual02_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual02_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual02_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual02_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual02_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual02_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual02_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual02_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual02_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual02_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual02_samples[,"s[18]"], type = "l")
```

```{r BYM K = 3 Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual02_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual02_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual02_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual02_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual02_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual02_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual02_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual02_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual02_samples[,"beta[8]"]))

# sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual02_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual02_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual02_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual02_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual02_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual02_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual02_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual02_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual02_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual02_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual02_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual02_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual02_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual02_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual02_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual02_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual02_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual02_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual02_samples[,"s[18]"]))
```


**Neighborhood structure 3: Distance-based neighbors (k = 5)**


```{r BYM K = 5 Model, echo = F, results = F, message = F}

# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_bym_03 = list(N = nrow(data.clean),                # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.5),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.5,                             # Adjacency matrix
                       num = num.nb.5,                          # Number of neighbors per district
                       weights = rep(1, length(adj.5)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_bym_03 <- list(beta0 = 0,
                           beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                           sigma2 = 1, 
                           s = rnorm(nrow(data.clean)),
                           v =  rep(0, nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
bym_usual03_model <- nimbleModel(code = usual_code_bym, constants = Consts_usual_bym_03, 
                             data = outcome, inits = Inits_usual_bym_03)

# (2) Define the compiled nimble model
bym_usual03_Cmodel <- compileNimble(bym_usual03_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
bym_usual03_conf <- configureMCMC(bym_usual03_model, monitors = c('beta0', 'beta', 'sigma2', 's', 'v'))

# (4) Print samplers
bym_usual03_conf$printSamplers()

# (5) Build MCMC object
bym_usual03_MCMC <- buildMCMC(bym_usual03_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
bym_usual03_CMCMC <- compileNimble(bym_usual03_MCMC, project = bym_usual03_Cmodel)  

# (7) Run the model
bym_usual03_runMCMC <- runMCMC(bym_usual03_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
bym_usual03_samples = rbind(bym_usual03_runMCMC$samples[[1]], bym_usual03_runMCMC$samples[[2]])
```

```{r BYM K = 5 Summaries}

# (9) WAIC ---------------------------------------------------------------------------------------
bym_usual03_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta 0 

# Calculating beta0 means
mean_beta0_bym_usual03 <- mean(bym_usual03_samples[ ,9])

# Calculating the beta0 95% CrI 
CrI_beta0_bym_usual03 <- t(quantile(bym_usual03_samples[ , 9], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_bym_usual03 <- cbind(mean_beta0_bym_usual03, CrI_beta0_bym_usual03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_bym_usual03)


################## Covariate Estimates: Beta

# Calculating the Beta means
means_betas_bym_usual03 <- apply(bym_usual03_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual03 <- t(apply(bym_usual03_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual03 <- t(matrix(c(means_betas_bym_usual03, CrI_betas_bym_usual03), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_bym_usual03)

################### Spatial effect per region: S

# Calculating the S means
means_s_bym_usual03 <- apply(bym_usual03_samples[ , 10:27],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_bym_usual03 <- t(apply(bym_usual03_samples[ , 10:27],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_bym_usual03 <- cbind(means_s_bym_usual03, CrI_s_bym_usual03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_bym_usual03)

################### V : estimates? per region

# Calculating the V means
means_v_bym_usual03 <- apply(bym_usual03_samples[ , 29:ncol(bym_usual03_samples)],2, mean)

# Calculating the V 95% CrI 
CrI_v_bym_usual03 <- t(apply(bym_usual03_samples[ , 29:ncol(bym_usual03_samples)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_v_bym_usual03 <- cbind(means_v_bym_usual03, CrI_v_bym_usual03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_v_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_bym_usual03)


```

```{r BYM K = 5 Fitted Values}
# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_bym_usual03 = matrix(NA, nrow=nrow(bym_usual03_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_bym_usual03[,i] = bym_usual03_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(bym_usual03_samples[,1:8]) + bym_usual03_samples[, s[i]] + bym_usual03_samples[, v[i]] 
}


# Mean fitted SIR
fitted_SIR_bym_usual03 <- exp(apply(fitted_bym_usual03, 2, mean))

# 95% CrI SIR
fitted_bym_usual03_CrI_SIR <- t(exp(apply(fitted_bym_usual03, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# Mean fitted Cases
fitted_bym_usual03_cases <- fitted_SIR_bym_usual03 *data.clean$Expected

# 95% CrI Cases
fitted_bym_usual03_CrI <-  fitted_bym_usual03_CrI_SIR *data.clean$Expected 

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_bym_usual03_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_bym_usual03,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_bym_usual03_cases), 
                                "CrI LL"    =  round(fitted_bym_usual03_CrI[,1]),
                                "CrI UL"    =  round(fitted_bym_usual03_CrI[,2]))


# Top 6 rows
head(fitted_bym_usual03_df)



```

```{r BYM K = 5 MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", bym_usual03_samples[,"beta0"], type = "l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual03_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual03_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual03_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual03_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual03_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual03_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual03_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual03_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual03_samples[,"sigma2"], type ="l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual03_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual03_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual03_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual03_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual03_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual03_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual03_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual03_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual03_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual03_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual03_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual03_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual03_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual03_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual03_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual03_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual03_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual03_samples[,"s[18]"], type = "l")
```

```{r BYM K = 5 Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual03_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual03_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual03_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual03_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual03_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual03_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual03_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual03_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual03_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual03_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual03_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual03_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual03_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual03_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual03_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual03_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual03_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual03_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual03_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual03_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual03_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual03_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual03_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual03_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual03_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual03_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual03_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual03_samples[,"s[18]"]))
```



## Ridge Regression: iCAR

```{r Ridge iCAR: Usual fixed priors model, echo = F}
#########################################
#    Usual fixed priors model - RIDGE     # 
#########################################

# Defining the usual fixed priors model ------------------------------------------------------
ridge_code <- nimbleCode({ 
  
  # Defining our priors
  beta0 ~ dnorm(0, sd = 200)
  
  for(j in 1:p){
    beta[j] ~ dnorm(0, sd=1*sqrt(1/lambda))  # Betas for the covariates
  }

  # Half-Cauchy priors for conditional std-dev & tuning param (lambda)
  #nu ~ T(dt(0, 1, 1),0,) 
  sigma ~ T(dt(0, 1, 1),0,) 
  lambda ~ T(dt(0, 1, 1),0,)

  
  # Defining transformed parameters
  tau2 <- 1 /(sigma^2)
  
  # CAR prior
  s[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau2, zero_mean = 1) #CAR prior
  
  # Defining likelihood
  for(i in 1:N) { 

    log(r[i]) <- beta0 + inprod(X[i, 1:p], beta[1:p]) + s[i]
    mu[i] <- E[i]*r[i]
    y[i] ~ dpois(mu[i])

  }
})

```

**Ridge : Neighborhood structure 1: Adjacent Neighbors**

```{r Ridge Adjacency-based Model, echo = F, results = F, message = F}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC
set.seed(1234)

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge_01 = list(N = nrow(data.clean),                  # Number of areas
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       L = length(adj),                       # Edges (length of adj vector)
                       E = data.clean$Expected,
                       adj = adj,                             # Adjacency matrix
                       num = num.nb,                          # Number of neighbors per district
                       weights = rep(1, length(adj)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0= 0, beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1, lambda=1, s=rnorm(nrow(data.clean)))

# Defining model ---------------------------------------------------------------------------------

# (1) Define ridge nimble model
ridge01_model = nimbleModel(code=ridge_code, constants=Consts_ridge_01, data=outcome,
                            inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge01_Cmodel=compileNimble(ridge01_model)

# (3) Configure the MCMC chain
ridge01_conf <- configureMCMC(ridge01_model, 
                              monitors = c('beta0',"beta", 'sigma', "lambda", 's'))

# (4) Do something
ridge01_conf$printSamplers()

# (5) Build MCMC object
ridge01_MCMC=buildMCMC(ridge01_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge01_CMCMC=compileNimble(ridge01_MCMC, project=ridge01_Cmodel)

# (7) Run the model
ridge01_runMCMC=runMCMC(ridge01_CMCMC, nburnin=50000, niter=200000, nchains=2, thin=10, WAIC=T)

# (8) Check convergence
ridge01_samples=rbind(ridge01_runMCMC$samples[[1]], ridge01_runMCMC$samples[[2]])
```

```{r Ridge Adjacency-based Summaries}

# (9) WAIC ---------
ridge01_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta 0 

mean_beta0_ridge01 <- mean(ridge01_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge01 <- t(quantile(ridge01_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge01 <- cbind(mean_beta0_ridge01, CrI_beta0_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge01)


################## Covariate Estimates: Beta

#Calculating the Beta means
means_betas_ridge01 <- apply(ridge01_samples[,1:8],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge01 <- t(apply(ridge01_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge01 <- t(matrix(c(means_betas_ridge01, CrI_betas_ridge01), ncol=8, byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge01)

################### Spatial effects by district

#Calculating the S means
means_s_ridge01 <- apply(ridge01_samples[ , 10:27],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge01 <- t(apply(ridge01_samples[ , 10:27],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge01 <- cbind(means_s_ridge01, CrI_s_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge01)


################### Sigma

#Calculating the sigma means
means_sigma_ridge01 <- mean(ridge01_samples[ , "sigma"])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge01 <- t(quantile(ridge01_samples[ , "sigma"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge01 <- cbind(means_sigma_ridge01, CrI_sigma_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge01)




################## Lambda

mean_beta0_ridge01 <- mean(ridge01_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge01 <- t(quantile(ridge01_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge01 <- cbind(mean_beta0_ridge01, CrI_beta0_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge01)

```

```{r Ridge Adjacency-based Fitted Values}
# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_ridge01 = matrix(NA, nrow=nrow(ridge01_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge01[,i] = ridge01_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(ridge01_samples[,1:8])  + ridge01_samples[, s[i]] 
    
}

# Mean fitted SIR
fitted_SIR_ridge01 <- exp(apply(fitted_ridge01, 2, mean))

# Mean fitted Cases
fitted_ridge01_cases <- fitted_SIR_ridge01*data.clean$Expected

# 95% CrI SIR
fitted_ridge01_CrI_SIR <- t(exp(apply(fitted_ridge01, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_ridge01_CrI <-  data.clean$Expected *fitted_ridge01_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge01_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_ridge01,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_ridge01_cases), 
                                "CrI LL"    =  round(fitted_ridge01_CrI[,1]),
                                "CrI UL"    =  round(fitted_ridge01_CrI[,2]))


# Top 6 rows
head(fitted_ridge01_df)



```

```{r Ridge Adjacency-based MCMC Chains, echo = F}
# Plot the MCMC chains----------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", ridge01_samples[,"sigma"], type ="l")

#Beta0
plot(main ="Intercept", ridge01_samples[,"beta0"], type = "l")

# lambda
plot(main ="Lambda", ridge01_samples[,"lambda"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  ridge01_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  ridge01_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge01_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge01_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge01_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge01_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge01_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge01_samples[,"beta[8]"] , type = "l")
plot(main = paste(names(data.clean[13])), ridge01_samples[,"beta[9]"] , type = "l")
plot(main = paste(names(data.clean[14])),ridge01_samples[,"beta[10]"] , type = "l")
plot(main = paste(names(data.clean[15])),ridge01_samples[,"beta[11]"] , type = "l")
plot(main = paste(names(data.clean[16])),ridge01_samples[,"beta[12]"] , type = "l")
plot(main = paste(names(data.clean[17])),ridge01_samples[,"beta[13]"] , type = "l")
plot(main = paste(names(data.clean[18])),ridge01_samples[,"beta[14]"] , type = "l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge01_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge01_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge01_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge01_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge01_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge01_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge01_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge01_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge01_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge01_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge01_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge01_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge01_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge01_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge01_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge01_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge01_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge01_samples[,"s[18]"], type = "l")



```

```{r Ridge Adjacency-based Posterior density curves, echo = F}


# Plot the density curves for posterior -------------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge01_samples[,"sigma2"]))

#Beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge01_samples[,"beta0"]))

#Lambda
plot(main ="Lambda", density(ridge01_samples[,"lambda"]))


# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(ridge01_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge01_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge01_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge01_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge01_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge01_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge01_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge01_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(ridge01_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(ridge01_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(ridge01_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(ridge01_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(ridge01_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(ridge01_samples[,"beta[14]"]))


#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge01_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge01_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge01_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge01_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge01_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge01_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge01_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge01_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge01_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge01_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge01_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge01_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge01_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge01_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge01_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge01_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge01_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge01_samples[,"s[18]"]))






```

**Ridge: Neighborhood structure 2: Distance-based neighbors (k = 3)**

```{r Ridge K = 3 Model , echo = F, results = F, message = F}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge_02 = list(N = nrow(data.clean),                  # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                     L = length(adj.3),                       # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj.3,                             # Adjacency matrix
                     num = num.nb.3,                          # Number of neighbors per district
                     weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=0, beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1,  lambda=1, s=rnorm(nrow(data.clean)))




# Defining model --------------------------------------------------------------------------------------------

# (1) Define ridge nimble model
ridge02_model=nimbleModel(code=ridge_code, constants=Consts_ridge_02, data=outcome, inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge02_Cmodel=compileNimble(ridge02_model)

# (3) Configure the MCMC chain
ridge02_conf <- configureMCMC(ridge02_model, 
                              monitors = c('beta0',"beta",'sigma', "lambda", 's'))

# (4) Do something
ridge02_conf$printSamplers()

# (5) Build MCMC object
ridge02_MCMC=buildMCMC(ridge02_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge02_CMCMC=compileNimble(ridge02_MCMC, project=ridge02_Cmodel)

# (7) Run the model
ridge02_runMCMC=runMCMC(ridge02_CMCMC, nburnin=50000, niter=200000, nchains=2, thin=10, WAIC=T)

# (8) Check convergence
ridge02_samples=rbind(ridge02_runMCMC$samples[[1]], ridge02_runMCMC$samples[[2]])


```

```{r Ridge K = 3 Summaries}

# (9) WAIC ---------
ridge02_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta 0 

mean_beta0_ridge02 <- mean(ridge02_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge02 <- t(quantile(ridge02_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge02 <- cbind(mean_beta0_ridge02, CrI_beta0_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge02)


################## Covariate Estimates: Beta

#Calculating the Beta means
means_betas_ridge02 <- apply(ridge02_samples[,1:8],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge02 <- t(apply(ridge02_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge02 <- t(matrix(c(means_betas_ridge02, CrI_betas_ridge02), ncol=8, byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge02)

################### Spatial effect per region: S

#Calculating the S means
means_s_ridge02 <- apply(ridge02_samples[ ,10:27],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge02 <- t(apply(ridge02_samples[ ,10:27],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge02 <- cbind(means_s_ridge02, CrI_s_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge02)


################### Sigma

#Calculating the sigma means
means_sigma_ridge02 <- mean(ridge02_samples[ , "sigma"])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge02 <- t(quantile(ridge02_samples[ , "sigma"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge02 <- cbind(means_sigma_ridge02, CrI_sigma_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge02)


################## Lambda

mean_beta0_ridge02 <- mean(ridge02_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge02 <- t(quantile(ridge02_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge02 <- cbind(mean_beta0_ridge02, CrI_beta0_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge02)

```

```{r Ridge K = 3 Fitted Values}
# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_ridge02 = matrix(NA, nrow=nrow(ridge02_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge02[,i] = ridge02_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(ridge02_samples[,1:8]) + ridge02_samples[, s[i]] 
    
}


# Mean fitted SIR
fitted_SIR_ridge02 <- exp(apply(fitted_ridge02, 2, mean))

# 95% CrI SIR
fitted_ridge02_CrI_SIR <- t(exp(apply(fitted_ridge02, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# Mean fitted Cases
fitted_ridge02_cases <- fitted_SIR_ridge02 * data.clean$Expected

# 95% CrI Cases
fitted_ridge02_CrI <-  fitted_ridge02_CrI_SIR *data.clean$Expected 

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge02_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_ridge02,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_ridge02_cases), 
                                "CrI LL"    =  round(fitted_ridge02_CrI[,1]),
                                "CrI UL"    =  round(fitted_ridge02_CrI[,2]))


# Top 6 rows
head(fitted_ridge02_df)



```

```{r Ridge K = 3 MCMC Chains, echo = F}

# Plot the MCMC chains----------


#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", ridge02_samples[,"sigma"], type ="l")

#Beta0
plot(main ="Intercept", ridge02_samples[,"beta0"], type = "l")

# lambda
plot(main ="Lambda", ridge02_samples[,"lambda"], type = "l")


# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  ridge02_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  ridge02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge02_samples[,"beta[8]"] , type = "l")
plot(main = paste(names(data.clean[13])), ridge02_samples[,"beta[9]"] , type = "l")
plot(main = paste(names(data.clean[14])),ridge02_samples[,"beta[10]"] , type = "l")
plot(main = paste(names(data.clean[15])),ridge02_samples[,"beta[11]"] , type = "l")
plot(main = paste(names(data.clean[16])),ridge02_samples[,"beta[12]"] , type = "l")
plot(main = paste(names(data.clean[17])),ridge02_samples[,"beta[13]"] , type = "l")
plot(main = paste(names(data.clean[18])),ridge02_samples[,"beta[14]"] , type = "l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge02_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge02_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge02_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge02_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge02_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge02_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge02_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge02_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge02_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge02_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge02_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge02_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge02_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge02_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge02_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge02_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge02_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge02_samples[,"s[18]"], type = "l")





```

```{r Ridge K = 3 Posterior density curves , echo = F}

# Plot the density curves for posterior -------------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge02_samples[,"sigma2"]))

#Beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge02_samples[,"beta0"]))

#Lambda
plot(main ="Lambda", density(ridge02_samples[,"lambda"]))

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(ridge02_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge02_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge02_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge02_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge02_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge02_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge02_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge02_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(ridge02_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(ridge02_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(ridge02_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(ridge02_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(ridge02_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(ridge02_samples[,"beta[14]"]))


#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge02_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge02_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge02_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge02_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge02_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge02_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge02_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge02_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge02_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge02_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge02_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge02_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge02_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge02_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge02_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge02_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge02_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge02_samples[,"s[18]"]))


```

**Ridge: Neighborhood structure 3: Distance-based neighbors (k = 5)**

```{r Ridge K = 5 Model, echo = F, results = F, message = F}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge_03 = list(N = nrow(data.clean),                  # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                     L = length(adj.5),                       # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj.5,                             # Adjacency matrix
                     num = num.nb.5,                          # Number of neighbors per district
                     weights = rep(1, length(adj.5)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=0, beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1, lambda=1, s=rnorm(nrow(data.clean)))




# Defining model --------------------------------------------------------------------------------------------

# (1) Define ridge nimble model
ridge03_model=nimbleModel(code=ridge_code, constants=Consts_ridge_03, data=outcome, inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge03_Cmodel=compileNimble(ridge03_model)

# (3) Configure the MCMC chain
ridge03_conf <- configureMCMC(ridge03_model, 
                              monitors = c('beta0',"beta",'sigma', "lambda", 's'))

# (4) Do something
ridge03_conf$printSamplers()

# (5) Build MCMC object
ridge03_MCMC=buildMCMC(ridge03_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge03_CMCMC=compileNimble(ridge03_MCMC, project=ridge03_Cmodel)

# (7) Run the model
ridge03_runMCMC=runMCMC(ridge03_CMCMC, nburnin=50000, niter=200000, nchains=2, thin=10, WAIC=T)

# (8) Check convergence
ridge03_samples=rbind(ridge03_runMCMC$samples[[1]], ridge03_runMCMC$samples[[2]])




```

```{r Ridge K = 5 Summaries}

# (9) WAIC ---------
ridge03_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta 0 

mean_beta0_ridge03 <- mean(ridge03_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge03 <- t(quantile(ridge03_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge03 <- cbind(mean_beta0_ridge03, CrI_beta0_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge03)



################## Covariate Estimates: Beta

#Calculating the Beta means
means_betas_ridge03 <- apply(ridge03_samples[,1:8],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge03 <- t(apply(ridge03_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge03 <- t(matrix(c(means_betas_ridge03, CrI_betas_ridge03), ncol=8, byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge03)

################### Spatial effect per region: S

#Calculating the S means
means_s_ridge03 <- apply(ridge03_samples[ , 10:27],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge03 <- t(apply(ridge03_samples[ , 10:27],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge03 <- cbind(means_s_ridge03, CrI_s_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge03)


################### Sigma

#Calculating the sigma means
means_sigma_ridge03 <- mean(ridge03_samples[ , "sigma"])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge03 <- t(quantile(ridge03_samples[ , "sigma"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge03 <- cbind(means_sigma_ridge03, CrI_sigma_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge03)



################## Lambda

mean_beta0_ridge03 <- mean(ridge03_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge03 <- t(quantile(ridge03_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge03 <- cbind(mean_beta0_ridge03, CrI_beta0_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge03)

```

```{r Ridge K=5 Fitted Values}
# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_ridge03 = matrix(NA, nrow=nrow(ridge03_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge03[,i] = ridge03_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%t(ridge03_samples[,1:8]) +  ridge03_samples[, s[i]] 

}


# Mean fitted SIR
fitted_SIR_ridge03 <- exp(apply(fitted_ridge03, 2, mean))

# Mean fitted Cases
fitted_ridge03_cases <- fitted_SIR_ridge03*data.clean$Expected

# 95% CrI SIR
fitted_ridge03_CrI_SIR <- t(exp(apply(fitted_ridge03, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_ridge03_CrI <-  data.clean$Expected *fitted_ridge03_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge03_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_ridge03,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_ridge03_cases), 
                                "CrI LL"    =  round(fitted_ridge03_CrI[,1]),
                                "CrI UL"    =  round(fitted_ridge03_CrI[,2]))


# Top 6 rows
head(fitted_ridge03_df)



```

```{r Ridge K=5 MCMC Chains, echo = F}
# Plot the MCMC chains----------


#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", ridge03_samples[,"sigma"], type ="l")

#Beta0
plot(main ="Intercept", ridge03_samples[,"beta0"], type = "l")

# lambda
plot(main ="Lambda", ridge03_samples[,"lambda"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  ridge03_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  ridge03_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge03_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge03_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge03_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge03_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge03_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge03_samples[,"beta[8]"] , type = "l")
plot(main = paste(names(data.clean[13])), ridge03_samples[,"beta[9]"] , type = "l")
plot(main = paste(names(data.clean[14])),ridge03_samples[,"beta[10]"] , type = "l")
plot(main = paste(names(data.clean[15])),ridge03_samples[,"beta[11]"] , type = "l")
plot(main = paste(names(data.clean[16])),ridge03_samples[,"beta[12]"] , type = "l")
plot(main = paste(names(data.clean[17])),ridge03_samples[,"beta[13]"] , type = "l")
plot(main = paste(names(data.clean[18])),ridge03_samples[,"beta[14]"] , type = "l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge03_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge03_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge03_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge03_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge03_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge03_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge03_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge03_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge03_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge03_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge03_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge03_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge03_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge03_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge03_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge03_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge03_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge03_samples[,"s[18]"], type = "l")


```

```{r Ridge K=5 Posterior density curves, echo = F}

# Plot the density curves for posterior -------------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge03_samples[,"sigma2"]))

#Beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge03_samples[,"beta0"]))

#Lambda
plot(main ="Lambda", density(ridge03_samples[,"lambda"]))

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(ridge03_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge03_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge03_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge03_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge03_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge03_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge03_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge03_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(ridge03_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(ridge03_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(ridge03_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(ridge03_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(ridge03_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(ridge03_samples[,"beta[14]"]))


#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge03_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge03_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge03_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge03_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge03_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge03_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge03_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge03_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge03_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge03_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge03_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge03_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge03_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge03_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge03_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge03_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge03_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge03_samples[,"s[18]"]))



```


## Ridge regression: BYM CAR

```{r Ridge BYM Usual Code, echo = F}
#########################################
#    Usual fixed priors model - RIDGE   # 
#########################################

# Defining the usual fixed priors model ------------------------------------------------------
ridge_code_bym <- nimbleCode({ 
  
  # Defining our priors
  beta0 ~ dnorm(0, sd = 200)
  
  for(j in 1:p){
    beta[j] ~ dnorm(0, sd=1*sqrt(1/lambda))  # Betas for the covariates
  }
  
  # Half-Cauchy priors for conditional std-dev & tuning param (lambda)
  #nu ~ T(dt(0, 1, 1),0,) 
  sigma ~ T(dt(0, 1, 1),0,) 
  lambda ~ T(dt(0, 1, 1),0,)

  # Defining transformed parameters
  tau2 <- 1/(sigma^2)
  
  # CAR prior
  s[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau2, zero_mean = 1)
  
  # Defining likelihood
  for(i in 1:N) { 
    log(r[i]) <- beta0 + inprod(X[i, 1:p], beta[1:p]) + s[i] + v[i]
    mu[i] <- E[i]*r[i]
    y[i] ~ dpois(mu[i])
    v[i] ~ dnorm(0, sigma)
  }
})
```

**Ridge : Neighborhood structure 1: Adjacent Neighbors**

```{r Ridge BYM Adjacency-based Model, echo = F, results = F, message = F}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge01_bym = list(N = nrow(data.clean),                              # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                     L = length(adj),                       # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj,                             # Adjacency matrix
                     num = num.nb,                          # Number of neighbors per district
                     weights = rep(1, length(adj)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=0, 
                    beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1, lambda=1, 
                    s = rnorm(nrow(data.clean)),
                    v =  rep(0, nrow(data.clean)))

# Defining model -----------------------------------------------------------------------------
# (1) Define ridge nimble model
ridge01_bym_model = nimbleModel(code=ridge_code_bym, constants=Consts_ridge01_bym, data=outcome,
                            inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge01_bym_Cmodel=compileNimble(ridge01_bym_model)

# (3) Configure the MCMC chain
ridge01_bym_conf <- configureMCMC(ridge01_bym_model, 
                              monitors = c('beta0',"beta", 'sigma', "lambda", 's', 'v'))
# (4) Do something
ridge01_bym_conf$printSamplers()

# (5) Build MCMC object
ridge01_bym_MCMC = buildMCMC(ridge01_bym_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge01_bym_CMCMC = compileNimble(ridge01_bym_MCMC, project=ridge01_bym_Cmodel)

# (7) Run the model
ridge01_bym_runMCMC = runMCMC(ridge01_bym_CMCMC, nburnin=10000, niter=200000, nchains=2, thin=25, WAIC=T)

# (8) Check convergence
ridge01_bym_samples = rbind(ridge01_bym_runMCMC$samples[[1]], ridge01_bym_runMCMC$samples[[2]])

```

```{r Ridge BYM Adjacency-based Summaries}

# (9) WAIC
ridge01_bym_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta0

mean_beta0_ridge01_bym <- mean(ridge01_bym_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge01_bym <- t(quantile(ridge01_bym_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge01_bym <- cbind(mean_beta0_ridge01_bym, CrI_beta0_ridge01_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge01_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge01_bym)


################## Covariate Estimates: Beta

#Calculating the Beta means 
means_betas_ridge01_bym <- apply(ridge01_bym_samples[,1:8],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge01_bym <- t(apply(ridge01_bym_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge01_bym <- t(matrix(c(means_betas_ridge01_bym, CrI_betas_ridge01_bym), ncol=8,  byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge01_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge01_bym)



################### Spatial effect per region: S

#Calculating the S means
means_s_ridge01_bym <- apply(ridge01_bym_samples[ ,s[1:18]],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge01_bym <- t(apply(ridge01_bym_samples[ , s[1:18]],2, 
                             function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge01_bym <- cbind(means_s_ridge01_bym, CrI_s_ridge01_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge01_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge01_bym)


################### Additional error variable: v

#Calculating the S means
means_v_ridge01_bym <- apply(ridge01_bym_samples[ ,v[1:18]],2, mean)

#Calculating the Beta 95% CrI 
CrI_v_ridge01_bym <- t(apply(ridge01_bym_samples[ , v[1:18]],2, 
                             function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_v_ridge01_bym <- cbind(means_v_ridge01_bym, CrI_v_ridge01_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_v_ridge01_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_ridge01_bym)


################### Sigma

#Calculating the sigma means
means_sigma_ridge01_bym <- mean(ridge01_bym_samples[ , "sigma"])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge01_bym <- t(quantile(ridge01_bym_samples[ , "sigma"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge01_bym <- cbind(means_sigma_ridge01_bym, CrI_sigma_ridge01_bym) %>%
  as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge01_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge01_bym)



################## Lambda

mean_lambda_ridge01_bym <- mean(ridge01_bym_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_lambda_ridge01_bym <- t(quantile(ridge01_bym_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_lambda_ridge01_bym <- cbind(mean_lambda_ridge01_bym, CrI_lambda_ridge01_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_lambda_ridge01_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_lambda_ridge01_bym)

```

```{r Ridge BYM Adjacency-based Fitted Values}
# (11) Fitted values  ----------------------------------------------------------------------------

#Creating matrix to store fitted values
fitted_ridge01_bym = matrix(NA, nrow=nrow(ridge01_bym_samples), ncol= nrow(data.clean))

#Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge01_bym[,i] = ridge01_bym_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%t(ridge01_bym_samples[,1:8])+ ridge01_bym_samples[, s[i]]+ ridge01_bym_samples[, v[i]] }


# Mean fitted SIR
fitted_SIR_ridge01_bym <- exp(apply(fitted_ridge01_bym, 2, mean))

# Mean fitted Cases
fitted_ridge01_bym_cases <- fitted_SIR_ridge01_bym*data.clean$Expected

# 95% CrI SIR
fitted_ridge01_CrI_SIR <- t(exp(apply(fitted_ridge01_bym, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_ridge01_bym_CrI <-  data.clean$Expected *fitted_ridge01_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge01_bym_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_ridge01_bym,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_ridge01_bym_cases), 
                                "CrI LL"    =  round(fitted_ridge01_bym_CrI[,1]),
                                "CrI UL"    =  round(fitted_ridge01_bym_CrI[,2]))


# Top 6 rows
head(fitted_ridge01_df)

```

```{r Ridge BYM Adjacency-based MCMC chains, echo = F}
# Beta0
plot(main ="Intercept", ridge01_bym_samples[,"beta0"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(2,4), mar =c(5, 3, 1, 2) + 0.1)
plot(main = paste(names(data.clean[5])),  ridge01_bym_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  ridge01_bym_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge01_bym_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge01_bym_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge01_bym_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge01_bym_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge01_bym_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge01_bym_samples[,"beta[8]"] , type = "l")

# sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma", ridge01_bym_samples[,"sigma"], type ="l")

# lambda
plot(main ="Lambda", ridge01_bym_samples[,"lambda"], type = "l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge01_bym_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge01_bym_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge01_bym_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge01_bym_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge01_bym_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge01_bym_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge01_bym_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge01_bym_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge01_bym_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge01_bym_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge01_bym_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge01_bym_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge01_bym_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge01_bym_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge01_bym_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge01_bym_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge01_bym_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge01_bym_samples[,"s[18]"], type = "l")
```

```{r Ridge BYM Adjacency-based Posterior density curves, echo = F}
# Betas (Covariates) - log scale
par(mfrow=c(3,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge01_bym_samples[,"beta0"]))
plot(main = paste(names(data.clean[5])),density(ridge01_bym_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge01_bym_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge01_bym_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge01_bym_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge01_bym_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge01_bym_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge01_bym_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge01_bym_samples[,"beta[8]"]))

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge01_bym_samples[,"sigma"]))

#Lambda
plot(main ="Lambda", density(ridge01_bym_samples[,"lambda"]))

#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge01_bym_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge01_bym_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge01_bym_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge01_bym_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge01_bym_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge01_bym_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge01_bym_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge01_bym_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge01_bym_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge01_bym_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge01_bym_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge01_bym_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge01_bym_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge01_bym_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge01_bym_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge01_bym_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge01_bym_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge01_bym_samples[,"s[18]"]))
```

**Ridge: Neighborhood structure 2: Distance-based neighbors (k = 3)**

```{r Ridge BYM K = 3 Model, echo = F, results = F, message = F}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge02_bym = list(N = nrow(data.clean),                              # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                     L = length(adj.3),                       # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj.3,                             # Adjacency matrix
                     num = num.nb.3,                          # Number of neighbors per district
                     weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=0, 
                    beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1, lambda=1, 
                    s = rnorm(nrow(data.clean)),
                    v =  rep(0, nrow(data.clean)))

# Defining model -----------------------------------------------------------------------------
# (1) Define ridge nimble model
ridge02_bym_model = nimbleModel(code=ridge_code_bym, 
                                constants=Consts_ridge02_bym, 
                                data=outcome,
                                inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge02_bym_Cmodel = compileNimble(ridge02_bym_model)

# (3) Configure the MCMC chain
ridge02_bym_conf <- configureMCMC(ridge02_bym_model, 
                              monitors = c('beta0',"beta", 'sigma', "lambda", 's', 'v'))
# (4) Do something
ridge02_bym_conf$printSamplers()

# (5) Build MCMC object
ridge02_bym_MCMC = buildMCMC(ridge02_bym_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge02_bym_CMCMC = compileNimble(ridge02_bym_MCMC, project=ridge02_bym_Cmodel)

# (7) Run the model
ridge02_bym_runMCMC = runMCMC(ridge02_bym_CMCMC, nburnin=10000, niter=200000, nchains=2, thin=25, WAIC=T)

# (8) Check convergence
ridge02_bym_samples = rbind(ridge02_bym_runMCMC$samples[[1]], ridge02_bym_runMCMC$samples[[2]])


```

```{r Ridge BYM K = 3 Summaries}

# (9) WAIC
ridge02_bym_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta0

mean_beta0_ridge02_bym <- mean(ridge02_bym_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge02_bym <- t(quantile(ridge02_bym_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge02_bym <- cbind(mean_beta0_ridge02_bym, CrI_beta0_ridge02_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge02_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge02_bym)


################## Covariate Estimates: Beta

#Calculating the Beta means 
means_betas_ridge02_bym <- apply(ridge02_bym_samples[,1:8],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge02_bym <- t(apply(ridge02_bym_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge02_bym <- t(matrix(c(means_betas_ridge02_bym, CrI_betas_ridge02_bym), ncol=8,  byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge02_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge02_bym)



################### Spatial effect per region: S

#Calculating the S means
means_s_ridge02_bym <- apply(ridge02_bym_samples[ ,s[1:18]],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge02_bym <- t(apply(ridge02_bym_samples[ , s[1:18]],2, 
                             function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge02_bym <- cbind(means_s_ridge02_bym, CrI_s_ridge02_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge02_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge02_bym)



################### Additional error variable: v

#Calculating the v means
means_v_ridge02_bym <- apply(ridge02_bym_samples[ ,v[1:18]],2, mean)

#Calculating the Beta 95% CrI 
CrI_v_ridge02_bym <- t(apply(ridge02_bym_samples[ , v[1:18]],2, 
                             function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_v_ridge02_bym <- cbind(means_v_ridge02_bym, CrI_v_ridge02_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_v_ridge02_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_ridge02_bym)



################### Sigma

#Calculating the sigma means
means_sigma_ridge02_bym <- mean(ridge02_bym_samples[ , "sigma"])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge02_bym <- t(quantile(ridge02_bym_samples[ , "sigma"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge02_bym <- cbind(means_sigma_ridge02_bym, CrI_sigma_ridge02_bym) %>%
  as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge02_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge02_bym)



################## Lambda

mean_lambda_ridge02_bym <- mean(ridge02_bym_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_lambda_ridge02_bym <- t(quantile(ridge02_bym_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_lambda_ridge02_bym <- cbind(mean_lambda_ridge02_bym, CrI_lambda_ridge02_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_lambda_ridge02_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_lambda_ridge02_bym)

```

```{r Ridge BYM K = 3 Fitted Values}
# (11) Fitted values  ----------------------------------------------------------------------------

#Creating matrix to store fitted values
fitted_ridge02_bym = matrix(NA, nrow=nrow(ridge02_bym_samples), ncol= nrow(data.clean))

#Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge02_bym[,i] = ridge02_bym_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%t(ridge02_bym_samples[,1:8])+ ridge02_bym_samples[, s[i]]+ ridge02_bym_samples[, v[i]] }


# Mean fitted SIR
fitted_SIR_ridge02_bym <- exp(apply(fitted_ridge02_bym, 2, mean))

# Mean fitted Cases
fitted_ridge02_bym_cases <- fitted_SIR_ridge02_bym*data.clean$Expected

# 95% CrI SIR
fitted_ridge02_CrI_SIR <- t(exp(apply(fitted_ridge02_bym, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_ridge02_bym_CrI <-  data.clean$Expected *fitted_ridge02_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge02_bym_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_ridge02_bym,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_ridge02_bym_cases), 
                                "CrI LL"    =  round(fitted_ridge02_bym_CrI[,1]),
                                "CrI UL"    =  round(fitted_ridge02_bym_CrI[,2]))


# Top 6 rows
head(fitted_ridge02_df)

cbind(fitted_ridge02_df[,4:6],fitted_ridge01_df[,4:6])
```

```{r Ridge BYM K = 3 MCMC chains, echo = F}
# Beta0
plot(main ="Intercept", ridge02_bym_samples[,"beta0"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(2,4), mar =c(5, 3, 1, 2) + 0.1)
plot(main = paste(names(data.clean[5])),  ridge02_bym_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  ridge02_bym_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge02_bym_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge02_bym_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge02_bym_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge02_bym_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge02_bym_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge02_bym_samples[,"beta[8]"] , type = "l")

# sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma", ridge02_bym_samples[,"sigma"], type ="l")

# lambda
plot(main ="Lambda", ridge02_bym_samples[,"lambda"], type = "l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge02_bym_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge02_bym_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge02_bym_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge02_bym_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge02_bym_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge02_bym_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge02_bym_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge02_bym_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge02_bym_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge02_bym_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge02_bym_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge02_bym_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge02_bym_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge02_bym_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge02_bym_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge02_bym_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge02_bym_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge02_bym_samples[,"s[18]"], type = "l")
```

```{r Ridge BYM K = 3 Posterior density curves, echo = F}
# Betas (Covariates) - log scale
par(mfrow=c(3,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge02_bym_samples[,"beta0"]))
plot(main = paste(names(data.clean[5])),density(ridge02_bym_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge02_bym_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge02_bym_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge02_bym_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge02_bym_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge02_bym_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge02_bym_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge02_bym_samples[,"beta[8]"]))

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge02_bym_samples[,"sigma"]))

#Lambda
plot(main ="Lambda", density(ridge02_bym_samples[,"lambda"]))

#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge02_bym_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge02_bym_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge02_bym_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge02_bym_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge02_bym_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge02_bym_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge02_bym_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge02_bym_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge02_bym_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge02_bym_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge02_bym_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge02_bym_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge02_bym_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge02_bym_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge02_bym_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge02_bym_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge02_bym_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge02_bym_samples[,"s[18]"]))
```

**Ridge: Neighborhood structure 3: Distance-based neighbors (k = 5)**

```{r Ridge BYM K = 5 Model, echo = F, results = F, message = F}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge03_bym = list(N = nrow(data.clean),             # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),  # Number ofcovariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),# Matrix of covariates
                     L = length(adj.5),                   # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj.5,                         # Adjacency matrix
                     num = num.nb.5,                      # Number of neighbors per district
                     weights = rep(1, length(adj.5)))     # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=0, 
                    beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1, lambda=1, 
                    s = rnorm(nrow(data.clean)),
                    v =  rep(0, nrow(data.clean)))

# Defining model -----------------------------------------------------------------------------
# (1) Define ridge nimble model
ridge03_bym_model = nimbleModel(code=ridge_code_bym, 
                                constants=Consts_ridge03_bym, 
                                data=outcome,
                                inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge03_bym_Cmodel = compileNimble(ridge03_bym_model)

# (3) Configure the MCMC chain
ridge03_bym_conf <- configureMCMC(ridge03_bym_model, 
                              monitors = c('beta0',"beta", 'sigma', "lambda", 's', 'v'))
# (4) Do something
ridge03_bym_conf$printSamplers()

# (5) Build MCMC object
ridge03_bym_MCMC = buildMCMC(ridge03_bym_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge03_bym_CMCMC = compileNimble(ridge03_bym_MCMC, project=ridge03_bym_Cmodel)

# (7) Run the model
ridge03_bym_runMCMC = runMCMC(ridge03_bym_CMCMC, nburnin=10000, niter=200000, nchains=2, thin=25, WAIC=T)

# (8) Check convergence
ridge03_bym_samples = rbind(ridge03_bym_runMCMC$samples[[1]], ridge03_bym_runMCMC$samples[[2]])


```

```{r Ridge BYM K = 5 Summaries}

# (9) WAIC
ridge03_bym_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################## Beta0

mean_beta0_ridge03_bym <- mean(ridge03_bym_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge03_bym <- t(quantile(ridge03_bym_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge03_bym <- cbind(mean_beta0_ridge03_bym, CrI_beta0_ridge03_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge03_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
round(exp(mean_CrI_beta0_ridge03_bym),2)

################## Covariate Estimates: Beta

#Calculating the Beta means 
means_betas_ridge03_bym <- apply(ridge03_bym_samples[,1:8],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge03_bym <- t(apply(ridge03_bym_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge03_bym <- t(matrix(c(means_betas_ridge03_bym, CrI_betas_ridge03_bym), ncol=8,  byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge03_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
round(exp(mean_CrI_betas_ridge03_bym),2)


################### Spatial effect per region: S

#Calculating the S means
means_s_ridge03_bym <- apply(ridge03_bym_samples[ ,s[1:18]],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge03_bym <- t(apply(ridge03_bym_samples[ , s[1:18]],2, 
                             function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge03_bym <- cbind(means_s_ridge03_bym, CrI_s_ridge03_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge03_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge03_bym)

################### Additional error variable: v

#Calculating the v means
means_v_ridge03_bym <- apply(ridge03_bym_samples[ ,v[1:18]],2, mean)

#Calculating the Beta 95% CrI 
CrI_v_ridge03_bym <- t(apply(ridge03_bym_samples[ , v[1:18]],2, 
                             function(x) quantile(x, probs=c(0.035,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_v_ridge03_bym <- cbind(means_v_ridge03_bym, CrI_v_ridge03_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_v_ridge03_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_ridge03_bym)

################### Sigma

#Calculating the sigma means
means_sigma_ridge03_bym <- mean(ridge03_bym_samples[ , "sigma"])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge03_bym <- t(quantile(ridge03_bym_samples[ , "sigma"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge03_bym <- cbind(means_sigma_ridge03_bym, CrI_sigma_ridge03_bym) %>%
  as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge03_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
round(mean_CrI_sigma_ridge03_bym,2)

#Tau
mean_CrI_tau_ridge03_bym <- 1/(mean_CrI_sigma_ridge03_bym)
round(mean_CrI_tau_ridge03_bym,3)
################## Lambda

mean_lambda_ridge03_bym <- mean(ridge03_bym_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_lambda_ridge03_bym <- t(quantile(ridge03_bym_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_lambda_ridge03_bym <- cbind(mean_lambda_ridge03_bym, CrI_lambda_ridge03_bym) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_lambda_ridge03_bym) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_lambda_ridge03_bym)

```

```{r Ridge BYM K = 5 Fitted Values}
# (11) Fitted values  ----------------------------------------------------------------------

#Creating matrix to store fitted values
fitted_ridge03_bym = matrix(NA, nrow=nrow(ridge03_bym_samples), ncol= nrow(data.clean))

#Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge03_bym[,i] = ridge03_bym_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*%t(ridge03_bym_samples[,1:8])+ ridge03_bym_samples[, s[i]]+ ridge03_bym_samples[, v[i]] }


# Mean fitted SIR
fitted_SIR_ridge03_bym <- exp(apply(fitted_ridge03_bym, 2, mean))

# Mean fitted Cases
fitted_ridge03_bym_cases <- fitted_SIR_ridge03_bym*data.clean$Expected

# 95% CrI SIR
fitted_ridge03_CrI_SIR <- t(exp(apply(fitted_ridge03_bym, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_ridge03_bym_CrI <-  data.clean$Expected *fitted_ridge03_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge03_bym_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_ridge03_bym,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_ridge03_bym_cases), 
                                "CrI LL"    =  round(fitted_ridge03_bym_CrI[,1]),
                                "CrI UL"    =  round(fitted_ridge03_bym_CrI[,2]))

# Top 6 rows
head(fitted_ridge03_bym_df)
write.csv(fitted_ridge03_bym_df, file = "~/Desktop/fitted_values.csv")

```

```{r Ridge BYM K = 5 MCMC chains, echo = F}
# Beta0
plot(main ="Intercept", ridge03_bym_samples[,"beta0"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(2,4), mar =c(5, 3, 1, 2) + 0.1)
plot(main = paste(names(data.clean[5])),  ridge03_bym_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  ridge03_bym_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge03_bym_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge03_bym_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge03_bym_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge03_bym_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge03_bym_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge03_bym_samples[,"beta[8]"] , type = "l")

# sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma", ridge03_bym_samples[,"sigma"], type ="l")

# lambda
plot(main ="Lambda", ridge03_bym_samples[,"lambda"], type = "l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge03_bym_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge03_bym_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge03_bym_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge03_bym_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge03_bym_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge03_bym_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge03_bym_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge03_bym_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge03_bym_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge03_bym_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge03_bym_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge03_bym_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge03_bym_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge03_bym_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge03_bym_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge03_bym_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge03_bym_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge03_bym_samples[,"s[18]"], type = "l")
```

```{r Ridge BYM K = 5 Posterior density curves, echo = F}
# Betas (Covariates) - log scale
par(mfrow=c(3,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge03_bym_samples[,"beta0"]))
plot(main = paste(names(data.clean[5])),density(ridge03_bym_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge03_bym_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge03_bym_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge03_bym_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge03_bym_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge03_bym_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge03_bym_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge03_bym_samples[,"beta[8]"]))

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge03_bym_samples[,"sigma"]))

#Lambda
plot(main ="Lambda", density(ridge03_bym_samples[,"lambda"]))

#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge03_bym_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge03_bym_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge03_bym_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge03_bym_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge03_bym_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge03_bym_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge03_bym_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge03_bym_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge03_bym_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge03_bym_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge03_bym_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge03_bym_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge03_bym_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge03_bym_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge03_bym_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge03_bym_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge03_bym_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge03_bym_samples[,"s[18]"]))
```

```{r labels for loops}
betas <- paste0("beta[", 1:8, "]")
s <- paste0("s[", 1:18, "]")
v <- paste0("v[", 1:18, "]")
```


# Summary of Inferential Results - iCAR, BYMCAR, Ridge (3 pages)

```{r WAICs by model}
# WAIC by ICAR model
WAIC.iCAR <- cbind(Adjescent= usual01_runMCMC$WAIC, K3= usual02_runMCMC$WAIC,K5= usual03_runMCMC$WAIC)
#WAIC.iCAR

# WAIC by BYM CAR model
WAIC.bymCAR <- cbind(Adjescent= bym_usual01_runMCMC$WAIC, K3= bym_usual02_runMCMC$WAIC,K5= bym_usual03_runMCMC$WAIC)
#WAIC.bymCAR

# WAIC by Ridge model - iCAR
WAIC.Ridge.iCAR <- cbind(Adjescent = ridge01_runMCMC$WAIC,  K3= ridge02_runMCMC$WAIC,  K5 = ridge03_runMCMC$WAIC)
#WAIC.Ridge.iCAR

# WAIC by Ridge model - BYM CAR
WAIC.Ridge.bymCAR <- cbind(Adjescent = ridge01_bym_runMCMC$WAIC,  K3= ridge02_bym_runMCMC$WAIC,  K5 = ridge03_bym_runMCMC$WAIC)
#WAIC.Ridge.bymCAR

WAICs <- rbind(WAIC.iCAR, WAIC.bymCAR,WAIC.Ridge.iCAR, WAIC.Ridge.bymCAR )
rownames(WAICs) <- c("Nimble iCAR", "Nimble BYM CAR", "Ridge iCAR", "Ridge BYM CAR")
WAICs

#Differences between Fitted and Observed Case Counts
differences_by_model <- with(data.clean, data.frame(nimble_car1 = (Cases -  fitted_usual01_cases    ),
                                                    nimble_car2 = (Cases -  fitted_usual02_cases    ),
                                                    nimble_car3 = (Cases -  fitted_usual03_cases    ),
                                                    nimble_bym1 = (Cases -  fitted_bym_usual01_cases),
                                                    nimble_bym2 = (Cases -  fitted_bym_usual02_cases),
                                                    nimble_bym3 = (Cases -  fitted_bym_usual03_cases),
                                                    ridge_car1  = (Cases -  fitted_ridge01_cases    ),
                                                    ridge_car2  = (Cases -  fitted_ridge02_cases    ),
                                                    ridge_car3  = (Cases -  fitted_ridge03_cases    ),
                                                    ridge_bym1  = (Cases -  fitted_ridge01_bym_cases) ,
                                                    ridge_bym2  = (Cases -  fitted_ridge02_bym_cases) ,
                                                    ridge_bym3  = (Cases -  fitted_ridge03_bym_cases) ))

# Mean Differences sorted in ascending order
mean_differences_by_model <- differences_by_model %>% round () %>% colMeans()  %>% sort(dec=F) 
mean_differences_by_model

# Models sorted in ascending order of mean differences
mean_differences_by_model%>% names()

#They don't align so well with the WAICs but I don't think that's a big concern. It may just be additional info for the appendix

#do you guys know whether we can obtain residuals from these models? She seems to like it when people plot the residuals back onto the map
```

# Conclusion (1 page)

# Appendix

# Archive

```{r Boxplots by district and region, echo = F}
#Plots of variables by Region

# # create graphing function
# HK.district.boxplots <- function(df, na.rm = TRUE, ...){
#   
#   # create for loop to produce ggplot2 graphs 
#   for (i in seq_along(names(df[,3:ncol(df)]))) { 
#     
#     # create plot for each district in df 
#     plot <- 
#       ggplot(df,
#              aes(Region, df[,i],group = District, colour = Region)) + 
#       
#       geom_boxplot(size=6, notch = T) +
#       
#       theme_pander() +
#       theme(legend.position="none") + 
#       labs(y="Value")+
#       
#       ggtitle(paste(names(Covariates[i]), '\n', 
#                     "By Region \n",
#                     sep=''))
# 
#     # print plots to screen
#     print(plot)
#   }
# }
# 
# # run graphing function on long df
# HK.district.boxplots(Covariates)
```

```{r Boxplot by region, echo = F}
# create graphing function
# HK.region.boxplots <- function(df, na.rm = TRUE, ...){
#   
#   # create for loop to produce ggplot2 graphs 
#   for (i in seq_along(names(df[,3:ncol(df)]))) { 
#     
#     # create plot for each district in df 
#     plot <- 
#       ggplot(df,
#              aes( x=Region, y=df[,i], fill = Region)) + 
#       
#       geom_boxplot(size=1, notch = F) +
#       
#       theme_pander() +
#       theme(legend.position="none") + 
#       labs(y="Value")
#       
#       ggtitle(paste(names(covariates[i]), '\n', 
#                     "By Region \n",
#                     sep=''))
# 
#     # print plots to screen
#     print(plot)
#   }
# }
# 
# # run graphing function on long df
# HK.region.boxplots(covariates)
```

```{r Histograms by district, echo = F}

# # create graphing function
# HK.histogram <- function(df, na.rm = TRUE, ...){
#   
#   # create for loop to produce ggplot2 graphs 
#   for (i in seq_along(names(df[,3:ncol(df)]))) { 
#     
#     # create plot for each district in df 
#     plot <- ggplot(df, aes(df[,i])) + 
#       geom_bar(position="dodge", aes(fill=Region, size=2) )+
#       #facet_wrap(~Region)
#       theme_pander() +
#       theme(legend.position="none") + 
#       labs(y="Value", x= paste(names(Covariates[i])))+
#       
#       ggtitle(paste(names(Covariates[i]), '\n', 
#                     "By Region \n",
#                     sep=''))
#     # print plots to screen
#     print(plot)
#   }
# }
# 
# # run graphing function on long df
# HK.histogram(Covariates)
```

```{r Histograms of new transformed variables, echo = F}
# # Histogram of SIR and new covariates ----------------------------------------------------------
# sir <-     ggplot(data = data, aes(SIR)) + 
#               geom_histogram() + ylab("Frequency")
# age1 <-    ggplot(data = data, aes(Prop_0.24)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Prop of 0-24 yrs old")
# age2 <-    ggplot(data = data, aes(Prop_25.64)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Prop of 25-64 yrs old")
# age3 <-    ggplot(data = data, aes(Prop_65)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Prop of 65+ yrs old")
# income <-  ggplot(data = data, aes(Log_income)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Log(Monthly income)")
# postsec <- ggplot(data = data, aes(Log_postsec)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Log(Prop with Post-Secondary Education)")
# 
# grid.arrange(sir, age1, age2, age3, income, postsec, ncol = 3)
```

```{r Map of 0-24 year olds, echo = F}
# Plot of Population of 0-14 years old ------------------------------------------------------------------
# plotg =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Prop0_14)) + 
#   ggtitle("Proportion of 0-14 years old") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)
```

```{r Map unused, echo = F}
# Plot of number of households ----------------------------------------------------------------------
# plot.house = 
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Num_household)) + 
#   ggtitle("Number of households") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of male population ------------------------------------------------------------------------
# plot.male = 
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = PropMale)) + 
#   ggtitle("Proportion of males") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of Number of housing units ----------------------------------------------------------------------
# plotk =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Housing)) + 
#   ggtitle("Number of Households") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of proportion of secondary education and higher -------------------------------------------
# plotj =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = SecEduc)) + 
#   ggtitle("Proportion with Secondary Education and higher") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of Income ----------------------------------------------------------------------------------------
# plotn =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Income)) + 
#   ggtitle("Monthly Income") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)
```

```{r Poisson regression}
# Poisson regression
#poi.fit <- glm(Cases ~ Pop_density + Prop_labor + Prop_0.24 + Prop_25.64 + Prop_65 + Prop_female +  Log_postsec +  beds_per_hosp  + household_poverty_rate + offset(log(Expected)), data = data.clean, family = poisson(link="log"))
```

```{r Building number of neighbors and adjacency list fo nimble, echo = F}
# Number of neighbors per district -------------------------------------------------

# 1) Having contiguous boundary point
# num.nb <- c()
# for(i in 1:n){
#   num.nb[i] <- sum(HK.nbmat.adj[i,])
# }

# 2) Having 3 nearest neighbors
# num.nb.3 <- c()
# for(i in 1:n){
#   num.nb.3[i] <- sum(HK.nbmat.3[i,])
# }

# 3) Having 5 nearest neighbors
# num.nb.5 <- c()
# for(i in 1:n){
#   num.nb.5[i] <- sum(HK.nbmat.5[i,])
# }

# Adjacency vectors -----------------------------------------------------------------

# 1) Having contiguous boundary point
## list of regions with their respective contiguous neighborhoods
#adj <- list()
#for(i in 1:n){
#  adj[[i]] <- c(which(HK.nbmat.adj[i,] == 1))
#}

# 2) Having 3 nearest neighbors  ------- This function leads to an error in the nimble code
#adj.3 <- c()
#adj.3 <- which(HK.nbmat.adj[1,] == 1)
#for(i in 2:n){
#  adj.3 <- c(adj.3, c(which(HK.nbmat.3[i,] == 1)))
#}

 #3) Having 5 nearest neighbors ------- This function leads to an error in the nimble code
#adj.5 <- c()
#adj.5 <- which(HK.nbmat.adj[1,] == 1)
#for(i in 2:n){
#  adj.5 <- c(adj.5, c(which(HK.nbmat.5[i,] == 1)))
#}
```

