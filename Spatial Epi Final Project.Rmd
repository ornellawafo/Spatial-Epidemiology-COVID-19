---
title: "Final Project"
subtitle: "EPIB 677, Winter 2020, McGill University"
author: "Zharmaine Ante, Demy Dam, Ornella Wafo Noubissie" 
date: "`r Sys.Date()`"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r include = FALSE}
## ---- Setup ------------------------------------------------------------------
knitr::opts_chunk$set(
  echo = TRUE,           # show code
  warning = FALSE,       # don't show warnings
  message = FALSE,       # don't show messages (less serious warnings)
  cache = FALSE,         # set to TRUE to save results from last compilation
  fig.align = "center",  # center figures
  fig.asp = 1,           # fig.aspect ratio
  fig.width = 4          # fig width
)
```

# Abstract (1 page)

# Introduction (1 page)

# Analysis Plan (2 pages)

# Descriptive and Univariate Analyses (3 pages)

## Data Cleaning

```{r Load packages, echo = F}
# Data manipulation
library(dplyr)
library(tidyr)

# Creating maps for exploratory analysis
library(spdep)
library(rgdal)
library(maptools)
library(sp)
library(RColorBrewer)
library(classInt)

# Creating graphs
library(ggplot2)
library(gridExtra)
library(ggthemes)
library(pander)

# Models
library(CARBayes)
library(nimble)
```

```{r Hong Kong line list, echo = F, results = F}
# Read in the COVID-19 line list from HK
Linelist <- read.csv("Hong Kong Line List.csv", header = T)

# Create binary variables to prepare for aggregationn
linelist <- Linelist %>%
              mutate(
                Male = ifelse(Gender == "M", 1, 0),
                # Age.0.14 = ifelse(Age >= 0 & Age < 15, 1, 0),
                # Age.15.24 = ifelse(Age >= 15 & Age < 25, 1, 0),
                # Age.25.64 = ifelse(Age >= 25 & Age < 65, 1, 0),
                # Age.65 = ifelse(Age >= 65, 1, 0),
                Cases = 1,
                Deaths = ifelse(Linelist$Outcomes == "Deceased", 1, 0),
                Imported = ifelse(Linelist$Case.classification == "Imported", 1, 0), 
                Resident = ifelse(Linelist$HK.residents == "HK resident", 1, 0), 
                Proxy = ifelse(Linelist$Proxy == "Yes", 1, 0) 
              )

# Rearrange dataframe to prepare for aggregation
linelist <- linelist %>%
              select(Case.ID, Region, District, Male, Age, # Age.0.14, Age.15.24, Age.25.64, Age.65,
                     Cases, Deaths, Proxy, Imported, Resident)

# Aggregate dataframe by Region, District, Gender
linelist.agg <- linelist %>%
                  group_by(Region, District) %>%
                  summarise(Cases = sum(Cases),
                            Deaths = sum(Deaths),
                            # P.age.0.14 = sum(Age.0.14)/sum(Cases),
                            # P.age.15.24 = sum(Age.15.24)/sum(Cases),
                            # P.age.25.64 = sum(Age.25.64)/sum(Cases),
                            # P.age.65 = sum(Age.65)/sum(Cases),
                            Age = mean(Age),
                            P.male = sum(Male)/sum(Cases),
                            Proxy = sum(Proxy),
                            Imported = sum(Imported),
                            Resident = sum(Resident))

# Summary of cleaned and aggregated data
summary(linelist.agg)
```

```{r Hong Kong covariates, echo = F, results = F}
# Updated covariates dataset
Covariates <- read.csv("Hong Kong Covariates V2.csv")

# Summary of raw covariates data
summary(Covariates)
cor(Covariates[,3:ncol(Covariates)])

# Absolute covariance values above 0.5
#var.cov <- list()
#for(i in 1:(ncol(data.clean)-1)){
#  var.cov[[i]] <- c(which(abs(cor(data.clean[,2:ncol(data.clean)])[,i]) > 0.7))
#}
#
#names(var.cov) <- paste(names(data.clean[2:ncol(data.clean)])) %>% as.vector()

#Version 1
#Covariates.v1 <- read.csv("Hong Kong Covariates.csv")
#head(Covariates.v1)
#summary(Covariates.v1)
```

```{r Merging datasets, echo = F, results = F}
# Merging the datasets by district
data <- merge(x = linelist.agg, y = Covariates, by = "District")
```

```{r Data manipulation, echo = F, results = F}
## 1) New age categories: 0-24, 25-64, 65+, 
data$Pct_0.24 = data$Pct_0.14 + data$Pct_15.24
data$Prop_0.24 = data$Pct_0.24/100
data$Prop_25.64 = data$Pct_25.64/100
data$Prop_65 = data$Pct_65/100

## 2) Re-calculate population-level variables, based on female and male counts
data$Total_pop = data$Male_count + data$Female_count
data$Pop_density = data$Total_pop/data$Area_km2
data$Prop_labor = data$Count_labor/data$Total_pop
data$Prop_male = data$Male_count/data$Total_pop
data$Prop_female = data$Female_count/data$Total_pop
data$Prop_poor = data$poor_individuals_000s/data$Total_pop
data$Prop_poor_household = data$poor_households/data$Num_household

## 3) Log-transformation of monthly income and education variables
data$Prop_sec = data$Pct_Sec/100
data$Prop_postsec = data$Pct_PostSec/100
data$Log_income = log(data$Monthly_income)
data$Log_sec = log(data$Prop_sec)
data$Log_postsec = log(data$Prop_postsec)

## 4) Calculate expected cases and SIR using standardization method
tot.case = sum(data$Cases)
tot.pop = sum(data$Total_pop)
ave.rate = tot.case/tot.pop
data$Expected = ave.rate*data$Total_pop
data$SIR = data$Cases/data$Expected

## 5) Log transform population density
data$log_pop_density <- log(data$Pop_density)

## 6) Calculate average hospital beds per hospital
data$beds_per_hosp <- with(data, Num_beds/Num_hosp)
```

```{r Final clean dataset, echo = F, results = F}
# Keep only variables we want to include in spatial analysis
data.clean <- data %>%
  dplyr::select(District,
         # Region = Region.x,
         Cases,
         Expected,
         SIR,
         # Deaths,
         # Mean.age = Age,
         # Prop.male = P.male,
         # Area_km2,
         Pop_density,
         # log_pop_density,
         Prop_labor,
         # Prop_female_labor,
         beds_per_hosp,
         Prop_0.24,
         Prop_25.64,
         Prop_65,
         Prop_female,
         # Mean_median_age,
         # Log_sec,
         Log_postsec)
         # household_poverty_rate)
         # Household_size,
         # Prop_poor) #highly correlated with log income
                      #very little variability in household size
```

## Exploratory analysis

```{r Summary of clean dataset, echo = F}
# Summary of final cleaned dataset
summary(data.clean)
```

```{r Correlation matrix and pairs plot, echo = F}
# Correlation matrix
cor(subset(data.clean, select = -District)) # Note: Female pop highly collinear with pop of 65+ and post-sec

```


```{r Histograms of selected variables, echo = F}
# Full dataset: Select variables and plot histograms ---------------------------------------------
data %>% 
 dplyr::select(Cases, 
               SIR,
               Pop_density,
               # log_pop_density, # Doesn't seemt to improve much
               Pct_0.24, 
               Pct_15.24, 
               Pct_25.64, 
               Pct_65, 
               Log_income, 
               Prop_labor, 
               Prop_male_labor, 
               Num_household,
               Mean_median_age, 
               Log_postsec, 
               Num_hosp, 
               Num_beds,
               beds_per_hosp) %>% 
  gather() %>%                             
  ggplot(aes(value)) +                     
    facet_wrap(~key, scales = "free") +    
    geom_histogram(bins = 5) +
    xlab("") + ylab("Frequency")

# Cleaned dataset: Select variables and plot histograms-------------------------------------------
data.clean %>% 
 dplyr::select(Cases, 
               SIR,
               Pop_density, 
               Prop_0.24, 
               Prop_25.64, 
               Prop_65, 
               Prop_labor,  
               Log_postsec,  
               Prop_female, 
               beds_per_hosp) %>%
  gather() %>%                             
  ggplot(aes(value)) +                     
    facet_wrap(~key, scales = "free") +    
    geom_histogram(bins = 5) +
    xlab("") + ylab("Frequency")
```

## Maps of the outcome and covariates

```{r Data manipulation for mapping, echo = F}
# Coordinates (centroids) by district -----------------------------------------------------------
HKcoords <- read.csv("HK_coords.csv", header = T)
HKcoords <- HKcoords[order(HKcoords$District), ]
data$Lat <- HKcoords$Lat
data$Long <- HKcoords$Long

# Adding variables in shapefile -----------------------------------------------------------------
shp_HK = readOGR("shp_HK/Hong_Kong_18_Districts.shp", stringsAsFactors = FALSE)
shp_HK = shp_HK[order(shp_HK$ENAME),]
shp_HK$Lat = data$Lat
shp_HK$Long = data$Long
shp_HK$Cases = data$Cases
shp_HK$Expected = data$Expected
shp_HK$SIR = data$SIR
shp_HK$Rate = (data$Cases/data$Total_pop)*100000
shp_HK$TotalPop = data$Total_pop
shp_HK$PopDens = data$Pop_density
shp_HK$LogPopDens = data$log_pop_density
shp_HK$PropMale = data$Prop_male
shp_HK$PropFemale = data$Prop_female
shp_HK$Prop0_24 = data$Prop_0.24
shp_HK$Prop25_64 = data$Prop_25.64
shp_HK$Prop65 = data$Prop_65
shp_HK$Income = data$Monthly_income
shp_HK$Housing = data$Num_household
shp_HK$Hosp = data$N.Hospital
shp_HK$HospBeds = data$Num_beds
shp_HK$SecEduc = data$Prop_sec
shp_HK$PostSec = data$Prop_postsec
shp_HK$PropLabor = data$Prop_labor
shp_HK$PropMaleLabor = data$Pct.Male.Labor
shp_HK$PropPoor = data$Prop_poor
shp_HK$PropPoorHousehold = data$Prop_poor_household
shp_HK$beds_per_hosp = data$beds_per_hosp

# Converting shapefile data to dataframe object -------------------------------------------------
# Merge the "fortified" data with the data from our spatial object
shp_HK$id = rownames(shp_HK@data)
shp = fortify(shp_HK)
shp_HK.df = merge(shp, shp_HK@data, by = "id")
```

```{r Mapping outcome by district, echo = F}
# Plot of Total COVID-19 cases (as continuous variable) -----------------------------------------
ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Cases)) + 
  ggtitle("Total COVID-19 cases, by district") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of Total COVID-19 cases (as discrete variable) --------------------------------------------
brks <- classIntervals(shp_HK$Cases, n=5, style="quantile")
brks <- brks$brks
shp_HK.df$CasesCat[shp_HK.df$Cases < 10] = 0
shp_HK.df$CasesCat[shp_HK.df$Cases >= 10 & shp_HK.df$Cases < 15] = 1
shp_HK.df$CasesCat[shp_HK.df$Cases >= 15 & shp_HK.df$Cases < 20] = 2
shp_HK.df$CasesCat[shp_HK.df$Cases >= 20 & shp_HK.df$Cases < 43] = 3
shp_HK.df$CasesCat[shp_HK.df$Cases >= 43] = 4
shp_HK.df$CasesCat = factor(shp_HK.df$CasesCat, levels = 0:4, labels = c("<10", "10-14", "15-19", "20-42", ">42"))

plota =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = CasesCat)) + 
  scale_fill_brewer(palette = "YlOrRd") +
  ggtitle("Total COVID-19 cases") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of COVID-19 rate per 100,000 ---------------------------------------------------------------
brks <-classIntervals(shp_HK$Rate, n=5, style="quantile")
brks <- brks$brks
shp_HK.df$RateCat[shp_HK.df$Rate < brks[2]] = 0
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[2] & shp_HK.df$Rate < brks[3]] = 1
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[3] & shp_HK.df$Rate < brks[4]] = 2
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[4] & shp_HK.df$Rate < brks[5]] = 3
shp_HK.df$RateCat[shp_HK.df$Rate >= brks[5]] = 4
shp_HK.df$RateCat = factor(shp_HK.df$RateCat, levels = 0:4, 
                           labels = c("<2.5", "2.5-3.2", "3.2-4.5", "4.5-13.6", ">13.6"))

plota2 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = RateCat)) + 
  scale_fill_brewer(palette = "YlOrRd") +
  ggtitle("Rate of COVID-19 per 100,000") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of SIR ------------------------------------------------------------------------------------
plota3 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = SIR)) + 
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  ggtitle("Standardized Incidence Ratio") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plota, plota2, plota3, ncol = 3)

```

```{r Mapping covariates by district, echo = F}

# Population density, female and HC capacity ######################################################

# Plot of population density ----------------------------------------------------------------------
plot.popdensity = 
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PopDens)) + 
  ggtitle("Population density") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of average number of beds per hospital ----------------------------------------------------
plot.bedshosp =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = beds_per_hosp)) + 
  ggtitle("N of beds per hospital") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of female population ----------------------------------------------------------------------
plot.female = 
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PropFemale)) + 
  ggtitle("Proportion of females") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plot.popdensity, plot.bedshosp, plot.female)


# Age composition ################################################################################

# Plot of population of 0-24 ---------------------------------------------------------------------
plot.age1 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Prop0_24)) + 
  ggtitle("Proportion of 0-24 years old") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of population of 25-64 years old ----------------------------------------------------------
plot.age2 =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Prop25_64)) + 
  ggtitle("Proportion of 25-64 years old") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of population of 65+ ----------------------------------------------------------------------
plot.age3 = 
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = Prop65)) + 
  ggtitle("Proportion of 65 and above") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plot.age1, plot.age2, plot.age3)


# SES ############################################################################################

# Plot of proportion labor ----------------------------------------------------------------------------
plot.labor =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PropLabor)) + 
  ggtitle("Proportion of Pop. in Labor Force") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

# Plot of proportion of post-sec educ ------------------------------------------------------------
plot.postsec =
  ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
  geom_polygon(data = shp_HK.df, aes(fill = PostSec)) + 
  ggtitle("Proportion with Post-Secondary Education") +
  scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
  theme(legend.title = element_blank(),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(), 
        panel.background = element_blank()) +
    coord_fixed(1.3)

grid.arrange(plot.labor, plot.postsec)
```

## Moran's I statistic spatial autocorrelation test

```{r Building neighborhood structure, echo = F, results = F}
# Build neighborhood object ----------------------------------------------------------------------
coords <- as.matrix(subset(HKcoords, select = c(Long, Lat)))
IDs <- shp_HK$ENAME

# 1) Having contiguous boundary point
HK.nb <- poly2nb(shp_HK, row.names = IDs)
summary(HK.nb)

# 2) Having 3 nearest neighbors
HK.nb3 <- knn2nb(knearneigh(coords, k = 3, longlat = TRUE), row.names = IDs, sym = T)
summary(HK.nb3)

# 3) Having 5 nearest neighbors
HK.nb5 <- knn2nb(knearneigh(coords, k = 5, longlat = TRUE), row.names = IDs, sym = T)

# Plot neighbourhood structure -------------------------------------------------------------------
plot(shp_HK, border="grey", main="Contiguous border", cex.main = 0.5)
plot(HK.nb, coords, add=TRUE)

plot(shp_HK, border="grey", main="K = 3 nearest neighbors")
plot(HK.nb3, coords, add=TRUE)

plot(shp_HK, border="grey", main="K = 5 nearest neighbors")
plot(HK.nb5, coords, add=TRUE)

# Convert neighborhood object to weight list -----------------------------------------------------
HK.wnb <-  nb2listw(HK.nb, style = "B", zero.policy = T)
HK.wnb3 <- nb2listw(HK.nb3, style = "B")
HK.wnb5 <- nb2listw(HK.nb5, style = "B")
```

```{r Univariate Poisson models}
poi.fit1 <- glm(Cases ~ Pop_density + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit2 <- glm(Cases ~ Prop_female + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit3 <- glm(Cases ~ Prop_0.24 + Prop_25.64 + Prop_65 + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit4 <- glm(Cases ~ Prop_labor + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit5 <- glm(Cases ~ beds_per_hosp + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit6 <- glm(Cases ~ Log_postsec + offset(log(Expected)), 
                data = data.clean, family = poisson(link = "log"))

poi.fit7 <- glm(Cases ~ Pop_density + Prop_female + Prop_0.24 + Prop_25.64 + Prop_65 + 
                Prop_labor + beds_per_hosp + Log_postsec + offset(log(Expected)), 
                data = data.clean, family = poisson(link="log"))
```

```{r Morans test, echo = F, results = T}
# Moran test for SIR -----------------------------------------------------------------------------
moran.sir1 <- moran.test(data$SIR, HK.wnb, zero.policy = T)
moran.sir2 <- moran.test(data$SIR, HK.wnb3)
moran.sir3 <- moran.test(data$SIR, HK.wnb5)

# Results of Moran's test for SIR
moran.sir1
moran.sir2
moran.sir3

# Moran test for glm residuals -------------------------------------------------------------------
moran.lm1 <- lm.morantest(poi.fit1, HK.wnb, zero.policy = T)
moran.lm2 <- lm.morantest(poi.fit2, HK.wnb, zero.policy = T)
moran.lm3 <- lm.morantest(poi.fit3, HK.wnb, zero.policy = T)
moran.lm4 <- lm.morantest(poi.fit4, HK.wnb, zero.policy = T)
moran.lm5 <- lm.morantest(poi.fit5, HK.wnb, zero.policy = T)
moran.lm6 <- lm.morantest(poi.fit6, HK.wnb, zero.policy = T)
moran.lm7 <- lm.morantest(poi.fit7, HK.wnb, zero.policy = T)

# Results of Moran's test for SIR
moran.lm1
moran.lm2
moran.lm3
moran.lm4
moran.lm5
moran.lm6
moran.lm7
```

## Poisson Model

```{r Poisson regression, echo = F}
# Poisson regression -----------------------------------------------------------------------------
poi.fit <- glm(Cases ~ . - District - SIR + offset(log(Expected)), 
               data = data.clean, family = poisson(link = "log"))
summary(poi.fit)

# Checking assumption of a Poisson model ---------------------------------------------------------
par(mfrow = c(1,2))
hist(poi.fit$residuals, main="COVID-19", xlab = "Raw residuals") # a bit skewed to the right
abline(v = 0, lty = 2, col = "red")

plot(rstandard(poi.fit), ylab = "standardized residuals") #some overdispersed residuals
abline(h = 0, lty = 2, col = "red")
par(mfrow = c(1,1))

# Overdispersion ---------------------------------------------------------------------------------
library(AER); library(car)
dispersiontest(poi.fit, alternative = "greater") 
# Based from the test, there is overdispersion 
# (indicates residual risk even after adjusting for the covariates)

# Checking for model fit (obs vs fitted) ---------------------------------------------------------
plot(x = poi.fit$fitted.values, y = data.clean$Cases, 
     bty="n", xlab="Fitted", ylab="Observed", main = "COVID-19")
abline(a=0,b=1,lwd=2)
```

## CAR Model

```{r Building neighbors and adjacency list for Nimble, echo = F}
# Converting neighborhood objects to matrix -----------------------------------------

# 1) Having contiguous boundary point
HK.nbmat.adj <- nb2mat(HK.nb, style = 'B', zero.policy = TRUE) 

# 2) Having 3 nearest neighbors
HK.nbmat.3 <- nb2mat(HK.nb3, style = 'B', zero.policy = TRUE) 

# 3) Having 5 nearest neighbors
HK.nbmat.5 <- nb2mat(HK.nb5, style = 'B', zero.policy = TRUE) 

# Number of neighbors per district --------------------------------------------------
n <- nrow(data.clean)

# 1) Having contiguous boundary point
num.nb <- rowSums(HK.nbmat.adj)

# 2) Having 3 nearest neighbors
num.nb.3 <- rowSums(HK.nbmat.3)

# 3) Having 5 nearest neighbors
num.nb.5 <- rowSums(HK.nbmat.5)

# Adjacency vectors -----------------------------------------------------------------

# 1) Having contiguous boundary point
adj <- c()
adj <- which(HK.nbmat.adj[1,] == 1)
for(i in 2:n){
  adj <- c(adj, c(which(HK.nbmat.adj[i,] == 1)))
}

# 2) Having 3 nearest neighbors 
adj.3 <- list()
for(i in 1:n){
  adj.3[[i]] <- c(which(HK.nbmat.3[i,] == 1))
}
adj.3 <- unlist(adj.3)

#3) Having 5 nearest neighbors 
adj.5 <- list()
for(i in 1:n){
  adj.5[[i]] <- c(which(HK.nbmat.5[i,] == 1))
}
adj.5 <- unlist(adj.5)
```

**Nimble: iCAR Usual fixed priors model**

```{r Nimble: iCAR Usual fixed priors model, echo = F}

set.seed(1234)

# Defining the usual fixed priors model ------------------------------------------------------
usual_code <- nimbleCode({
  
  # Defining our priors
  beta0 ~ dnorm(0, sd = 100)
  for(j in 1:p){
    beta[j] ~ dnorm(0, sd = 100)  #Betas for the covariates
  }
  sigma2 ~ dinvgamma(1, 0.01)

  #sigma2 ~ dinvgamma(1, 10) 
  # tau2 ~ dinvgamma(2, 0.10) 
  #here i set up a prior for tau directly, it makes the MCMC converge better
  
  # Defining transformed parameters
  tau2 <- 1/sigma2
  s[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau2, zero_mean = 1) #CAR prior
  # Spatial effects (dcar is long vector, weights, n neighbors, zero mean = 1 constrains sum to 0)

  # Defining likelihood 
  for(i in 1:N) { 
    log(r[i]) <- beta0 + inprod(X[i, 1:p], beta[1:p]) + s[i]
    mu[i] <- E[i]*r[i] 
    y[i] ~ dpois(mu[i]) 
  } 
})
```

**Neighborhood structure 1: Adjacency-based neighbors**

```{r iCAR Adjacency-based, echo = F, results = F}
# Defining the data that goes into the model -----------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_01 = list(N = nrow(data.clean),                  # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj),                       # Edges (length of adj vector)
                       E = data.clean$Expected,               # Expected cases
                       adj = adj,                             # Adjacency matrix
                       num = num.nb,                          # Number of neighbors per district
                       weights = rep(1, length(adj)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual <- list(beta0 = -21,
                    beta = rep(0, ncol(data.clean[, 5:ncol(data.clean)])), 
                    sigma2 = 1, 
                    #tau2 = 0.1,
                    s = rnorm(length(num.nb)))

# Defining model -------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
usual01_model <- nimbleModel(code = usual_code, constants = Consts_usual_01, data = outcome, inits = Inits_usual)

# (2) Define the compiled nimble model
usual01_Cmodel <- compileNimble(usual01_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
usual01_conf <- configureMCMC(usual01_model, monitors = c('beta0', 'beta', 'sigma2', 's'))

# (4) Print samplers
usual01_conf$printSamplers()

# (5) Build MCMC object
usual01_MCMC <- buildMCMC(usual01_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
usual01_CMCMC <- compileNimble(usual01_MCMC, project = usual01_Cmodel)  

# (7) Run the model
usual01_runMCMC <- runMCMC(usual01_CMCMC, niter = 200000, nburnin = 15000, thin = 20, nchains = 2, WAIC = T)

# (8) Check convergence
usual01_samples = rbind(usual01_runMCMC$samples[[1]], usual01_runMCMC$samples[[2]])
# Results ----------------------------------------------------------------------------------------

# (9) WAIC ---------------------------------------------------------------------------------------
usual01_runMCMC$WAIC

# (10) Posterior summaries: Means and CrIs -------------------------------------------------------

################### Beta = Covariate estimates?

# Calculating the Beta means
means_betas_usual_01 <- apply(usual01_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_usual_01 <- t(apply(usual01_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_01 <- t(matrix(c(means_betas_usual_01, CrI_betas_usual_01), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_01)

################### S : estimates? per region

# Calculating the S means
means_s_usual_01 <- apply(usual01_samples[ ,8:(ncol(usual01_samples)-1)],2, mean)

# Calculating the S 95% CrI 
CrI_s_usual_01 <- t(apply(usual01_samples[ ,8:(ncol(usual01_samples)-1)],2, function(x) quantile(x, probs=c(0.015,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_01 <- cbind(means_s_usual_01, CrI_s_usual_01) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_01)

################## beta 0 

# Calculating the beta0 means
mean_beta0_usual01 <- mean(usual01_samples[ ,7])

# Calculating the Beta 95% CrI 
CrI_beta0_usual_01 <- t(quantile(usual01_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_01 <- cbind(mean_beta0_usual01, CrI_beta0_usual_01) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_usual_01)

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_usual01 = matrix(NA, nrow=nrow(usual01_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_usual01[,i] = usual01_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% 
<<<<<<< HEAD
    t(usual01_samples[,1:8]) + usual01_samples[, 10+i-1] 
=======
    t(usual01_samples[,1:8]) + usual01_samples[, 8+i-1] 
>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf
}

# Fitted values - distribution
fitted_usual_01_dist <- data.clean$Expected * exp(fitted_usual01)

<<<<<<< HEAD
# Mean fitted SIR
fitted_SIR_usual01 <- exp(apply(fitted_usual01, 2, mean))

# Mean fitted Cases
fitted_usual_01 <- fitted_SIR_usual01*data.clean$Expected

# 95% CrI SIR
fitted_usual_01_CrI_SIR <- t(exp(apply(fitted_usual01, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_usual_01_CrI <-  data.clean$Expected *fitted_usual_01_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_usual01_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_usual01,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_usual_01), 
                                "CrI LL"    =  round(fitted_usual_01_CrI[,1]),
                                "CrI UL"    =  round(fitted_usual_01_CrI[,2]))

=======
# Mean fitted values
fitted_usual_01 <- apply(fitted_usual_01_dist, 2, mean)

# 95% CrI
fitted_usual_01_CrI <- t(apply(fitted_usual_01_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_usual01_df <- cbind(fitted_usual_01,fitted_usual_01_CrI )

# Renaming columns
colnames(fitted_usual01_df) <- c("fitted_mean_usual01", "fitted_lower_usual01" , "fitted_upper_usual01")
>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf

# Top 6 rows
head(fitted_usual01_df)

<<<<<<< HEAD
 
=======
# Predicted vs observed cases
cbind(Observed=data.clean$Cases,fitted_usual01_df)
>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf
```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", usual01_samples[,"beta0"], type ="l")

# betas (covariates) - log scale
par(mfrow=c(4,2), mar=c(3, 3, 3, 2) + 0.1)
plot(main = paste(names(data.clean[5])),  usual01_samples[,"beta[1]"] , type = "l", ylab = "") 
plot(main = paste(names(data.clean[6])),  usual01_samples[,"beta[2]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[7])),  usual01_samples[,"beta[3]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[8])),  usual01_samples[,"beta[4]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[9])),  usual01_samples[,"beta[5]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[10])), usual01_samples[,"beta[6]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[11])), usual01_samples[,"beta[7]"] , type = "l", ylab = "")
plot(main = paste(names(data.clean[12])), usual01_samples[,"beta[8]"] , type = "l", ylab = "")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", usual01_samples[,"sigma2"], type = "l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), usual01_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), usual01_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), usual01_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), usual01_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), usual01_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), usual01_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), usual01_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), usual01_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), usual01_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), usual01_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), usual01_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), usual01_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), usual01_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), usual01_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), usual01_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), usual01_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), usual01_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), usual01_samples[,"s[18]"], type = "l")
```

```{r Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(usual01_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(usual01_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(usual01_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(usual01_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(usual01_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(usual01_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(usual01_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(usual01_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(usual01_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(usual01_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(usual01_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(usual01_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(usual01_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(usual01_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(usual01_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(usual01_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(usual01_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(usual01_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(usual01_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(usual01_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(usual01_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(usual01_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(usual01_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(usual01_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(usual01_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(usual01_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(usual01_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(usual01_samples[,"s[18]"]))
```

**Neighborhood structure 2: Distance-based neighbors (k = 3)**
```{r iCAR K3}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_02 = list(N = nrow(data.clean),                    # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.3),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.3,                             # Adjacency matrix
                       num = num.nb.3,                          # Number of neighbors per district
                       weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_02 <- list(beta0 = 0,
                    beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                    sigma2 = 1, 
                    s = rnorm(num.nb.3))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
usual02_model <- nimbleModel(code = usual_code, constants = Consts_usual_02, data = outcome, inits = Inits_usual_02)

# (2) Define the compiled nimble model
usual02_Cmodel <- compileNimble(usual02_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
usual02_conf <- configureMCMC(usual02_model, monitors = c('beta0', 'beta', 'sigma2', 's'))

# (4) Print samplers
usual02_conf$printSamplers()

# (5) Build MCMC object
usual02_MCMC <- buildMCMC(usual02_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
usual02_CMCMC <- compileNimble(usual02_MCMC, project = usual02_Cmodel)  

# (7) Run the model
usual02_runMCMC <- runMCMC(usual02_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
usual02_samples = rbind(usual02_runMCMC$samples[[1]], usual02_runMCMC$samples[[2]])

# Results ----------------------------------------------------------------------------------------

# (9) WAIC ---------------------------------------------------------------------------------------
usual02_runMCMC$WAIC

# (10) Posterior summaries -----------------------------------------------------------------------

################### Betas : Covariate estimates

# Calculating the Beta means
means_betas_usual_02=apply(usual02_samples[,1:8],2, mean)
<<<<<<< HEAD

# Calculating the Beta 95% CrI 
CrI_betas_usual_02=t(apply(usual02_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_02 <- t(matrix(c(means_betas_usual_02, CrI_betas_usual_02), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_02)

################### S : estimates? per region

# Calculating the S means
means_s_usual_02 <- apply(usual02_samples[ ,8:(ncol(usual02_samples)-1)],2, mean)

# Calculating the S 95% CrI 
CrI_s_usual_02 <- t(apply(usual02_samples[ ,8:(ncol(usual02_samples)-1)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_02 <- cbind(means_s_usual_02, CrI_s_usual_02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_02)

################## beta0 

# Calculating the beta0 means
mean_beta0_usual02 <- mean(usual02_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_usual_02 <- t(quantile(usual02_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_02 <- cbind(mean_beta0_usual02, CrI_beta0_usual_02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_usual_02)

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_usual02 = matrix(NA, nrow=nrow(usual02_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_usual02[,i] = usual02_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% 
    t(usual02_samples[,1:8]) + usual02_samples[, 10+i-1] 
}

# Fitted values - distribution
fitted_usual_02_dist <- data.clean$Expected * exp(fitted_usual02)

# Mean fitted SIR
fitted_SIR_usual02 <- exp(apply(fitted_usual02, 2, mean))

# Mean fitted Cases
fitted_usual_02 <- fitted_SIR_usual02*data.clean$Expected

# 95% CrI SIR
fitted_usual_02_CrI_SIR <- t(exp(apply(fitted_usual02, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_usual_02_CrI <-  data.clean$Expected *fitted_usual_02_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_usual02_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_usual02,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_usual_02), 
                                "CrI LL"    =  round(fitted_usual_02_CrI[,1]),
                                "CrI UL"    =  round(fitted_usual_02_CrI[,2]))


# Top 6 rows
head(fitted_usual02_df)

 
```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", usual02_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  usual02_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  usual02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  usual02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  usual02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  usual02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), usual02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), usual02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), usual02_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", usual02_samples[,"sigma2"], type = "l")

=======

# Calculating the Beta 95% CrI 
CrI_betas_usual_02=t(apply(usual02_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_02 <- t(matrix(c(means_betas_usual_02, CrI_betas_usual_02), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_02)

################### S : estimates? per region

# Calculating the S means
means_s_usual_02 <- apply(usual02_samples[ ,8:(ncol(usual02_samples)-1)],2, mean)

# Calculating the S 95% CrI 
CrI_s_usual_02 <- t(apply(usual02_samples[ ,8:(ncol(usual02_samples)-1)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_02 <- cbind(means_s_usual_02, CrI_s_usual_02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_02)

################## beta0 

# Calculating the beta0 means
mean_beta0_usual02 <- mean(usual02_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_usual_02 <- t(quantile(usual02_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_02 <- cbind(mean_beta0_usual02, CrI_beta0_usual_02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_usual_02)

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_usual02 = matrix(NA, nrow=nrow(usual02_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_usual02[,i] = usual02_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% 
    t(usual02_samples[,1:8]) + usual02_samples[, 8+i-1] 
}

# Fitted values - distribution
fitted_usual_02_dist <- data.clean$Expected * exp(fitted_usual02)

# Mean fitted values
fitted_usual_02 <- apply(fitted_usual_02_dist, 2, mean)

# 95% CrI
fitted_usual_02_CrI <- t(apply(fitted_usual_02_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))

# Creating dataframe to store fitted values and quantiles in regular svale
fitted_usual02_df <- cbind(fitted_usual_02,fitted_usual_02_CrI)

# Renaming columns
colnames(fitted_usual02_df) <- c("fitted_mean_usual02", "fitted_lower_usual02" , "fitted_upper_usual02")

# Top 6 rows
head(fitted_usual02_df)

# Predicted vs observed cases
cbind(data.clean$Cases,fitted_usual02_df)
```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", usual02_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  usual02_samples[,"beta[1]"] , type = "l") 
plot(main = paste(names(data.clean[6])),  usual02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  usual02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  usual02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  usual02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), usual02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), usual02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), usual02_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", usual02_samples[,"sigma2"], type = "l")

>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf
# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), usual02_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), usual02_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), usual02_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), usual02_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), usual02_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), usual02_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), usual02_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), usual02_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), usual02_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), usual02_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), usual02_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), usual02_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), usual02_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), usual02_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), usual02_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), usual02_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), usual02_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), usual02_samples[,"s[18]"], type = "l")
```

```{r Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(usual02_samples[,"beta0"]))

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(usual02_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(usual02_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(usual02_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(usual02_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(usual02_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(usual02_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(usual02_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(usual02_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(usual02_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(usual02_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(usual02_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(usual02_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(usual02_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(usual02_samples[,"beta[14]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(usual02_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(usual02_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(usual02_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(usual02_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(usual02_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(usual02_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(usual02_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(usual02_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(usual02_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(usual02_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(usual02_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(usual02_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(usual02_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(usual02_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(usual02_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(usual02_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(usual02_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(usual02_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(usual02_samples[,"s[18]"]))
```

**Neighborhood structure 3: Distance-based neighbors (k = 5)**

```{r iCAR K5}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_03 = list(N = nrow(data.clean),                    # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.5),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.5,                             # Adjacency matrix
                       num = num.nb.5,                          # Number of neighbors per district
                       weights = rep(1, length(adj.5)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_03 <- list(beta0 = 0,
                    beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                    sigma2 = 1, 
                    s = rnorm(num.nb.5)) 

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
usual03_model <- nimbleModel(code = usual_code, constants = Consts_usual_03, data = outcome, inits = Inits_usual_03)

# (2) Define the compiled nimble model
usual03_Cmodel <- compileNimble(usual03_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
usual03_conf <- configureMCMC(usual03_model, monitors = c('beta0', 'beta', 'sigma2', 's'))

# (4) Print samplers
usual03_conf$printSamplers()

# (5) Build MCMC object
usual03_MCMC <- buildMCMC(usual03_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
usual03_CMCMC <- compileNimble(usual03_MCMC, project = usual03_Cmodel)  

# (7) Run the model
usual03_runMCMC <- runMCMC(usual03_CMCMC, nburnin = 50000, niter = 200000, nchains = 2, thin = 5, WAIC = T)

# (8) Check convergence
usual03_samples = rbind(usual03_runMCMC$samples[[1]], usual03_runMCMC$samples[[2]])

# Results ----------------------------------------------------------------------------------------

# (9) WAIC ---------------------------------------------------------------------------------------
usual03_runMCMC$WAIC
<<<<<<< HEAD

# (10) Posterior summaries------------------------------------------------------------------------
=======

# (10) Posterior summaries------------------------------------------------------------------------

################### Betas - covariate estimates

# Calculating the Beta means
means_betas_usual_03=apply(usual03_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_usual_03=t(apply(usual03_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_03 <- t(matrix(c(means_betas_usual_03, CrI_betas_usual_03), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_03)
>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf

################### Betas - covariate estimates

<<<<<<< HEAD
# Calculating the Beta means
means_betas_usual_03=apply(usual03_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_usual_03=t(apply(usual03_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_usual_03 <- t(matrix(c(means_betas_usual_03, CrI_betas_usual_03), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_usual_03)

################### S : estimates? per region

# Calculating the S means
means_s_usual_03 <- apply(usual03_samples[ ,8:(ncol(usual03_samples)-1)],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_usual_03 <- t(apply(usual03_samples[ ,8:(ncol(usual03_samples)-1)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_03 <- cbind(means_s_usual_03, CrI_s_usual_03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_03)

################## beta0 

# Calculating the beta0 means
mean_beta0_usual03 <- mean(usual03_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_usual_03 <- t(quantile(usual03_samples[ ,7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_03 <- cbind(mean_beta0_usual03, CrI_beta0_usual_03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
=======
# Calculating the S means
means_s_usual_03 <- apply(usual03_samples[ ,8:(ncol(usual03_samples)-1)],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_usual_03 <- t(apply(usual03_samples[ ,8:(ncol(usual03_samples)-1)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_usual_03 <- cbind(means_s_usual_03, CrI_s_usual_03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_usual_03)

################## beta0 

# Calculating the beta0 means
mean_beta0_usual03 <- mean(usual03_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_usual_03 <- t(quantile(usual03_samples[ ,7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_usual_03 <- cbind(mean_beta0_usual03, CrI_beta0_usual_03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_usual_03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf
exp(mean_CrI_beta0_usual_03)

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_usual03 = matrix(NA, nrow=nrow(usual03_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_usual03[,i] = usual03_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% 

    t(usual03_samples[,1:8]) + usual03_samples[, 10+i-1] 

# Fitted values - distribution
fitted_usual_03_dist <- data.clean$Expected * exp(fitted_usual03)


# Mean fitted SIR
fitted_SIR_usual03 <- exp(apply(fitted_usual03, 2, mean))

# Mean fitted Cases
fitted_usual_03 <- fitted_SIR_usual03*data.clean$Expected

# 95% CrI SIR
fitted_usual_03_CrI_SIR <- t(exp(apply(fitted_usual03, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_usual_03_CrI <-  data.clean$Expected *fitted_usual_03_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_usual03_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_usual03,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_usual_03), 
                                "CrI LL"    =  round(fitted_usual_03_CrI[,1]),
                                "CrI UL"    =  round(fitted_usual_03_CrI[,2]))


# Top 6 rows
head(fitted_usual03_df)

```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", usual03_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  usual03_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  usual03_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  usual03_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  usual03_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  usual03_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), usual03_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), usual03_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), usual03_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", usual03_samples[,"sigma2"], type = "l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), usual03_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), usual03_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), usual03_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), usual03_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), usual03_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), usual03_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), usual03_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), usual03_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), usual03_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), usual03_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), usual03_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), usual03_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), usual03_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), usual03_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), usual03_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), usual03_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), usual03_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), usual03_samples[,"s[18]"], type = "l")
```

```{r Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(usual03_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(usual03_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(usual03_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(usual03_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(usual03_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(usual03_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(usual03_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(usual03_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(usual03_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(usual03_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(usual03_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(usual03_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(usual03_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(usual03_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(usual03_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(usual03_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(usual03_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(usual03_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(usual03_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(usual03_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(usual03_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(usual03_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(usual03_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(usual03_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(usual03_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(usual03_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(usual03_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(usual03_samples[,"s[18]"]))
```

## BYM CAR

**Nimble: BYMCAR Usual fixed priors model**

```{r Nimble: Usual fixed priors model, echo = F}
# Defining the usual fixed priors model ------------------------------------------------------
usual_code_bym <- nimbleCode({ 

  # Defining our priors
  beta0 ~ dnorm(0, sd = 100)
  for(j in 1:p){
    beta[j] ~ dnorm(0, sd = 100)  # Betas for the covariates
  }
  sigma2 ~ dinvgamma(1, 0.01)     # Good b/c full conditional is IG --> makes MCMC easier

  # Defining transformed parameters
  # tauv ~ dinvgamma(1, 0.01) 
  tau2 <- 1/sigma2
  s[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau2, zero_mean = 1) # CAR prior

  # Defining likelihood
  for(i in 1:N) { # inprod (beta1X + beta 2X)?
    log(mu[i]) <- log(E[i]) + beta0+ inprod(X[i, 1:p], beta[1:p]) + s[i] + v[i] 
    y[i] ~ dpois(mu[i]) 
    v[i] ~ dnorm(0,100) 
  }
})
```

**Neighborhood structure 1: Adjacency-based neighbors**


```{r Nimble BYMCAR Adjacency}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_bym_01 = list(N = nrow(data.clean),              # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj),                       # Edges (length of adj vector)
                       E = data.clean$Expected,               # Expected cases
                       adj = adj,                             # Adjacency matrix
                       num = num.nb,                          # Number of neighbors per district
                       weights = rep(1, length(adj)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_bym_01 <- list(beta0 = 0,
                           beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                           sigma2 = 1, 
                           s = rnorm(num.nb),
                           v =  rep(0, nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
bym_usual01_model <- nimbleModel(code = usual_code_bym, constants = Consts_usual_bym_01, 
                             data = outcome, inits = Inits_usual_bym_01)

# (2) Define the compiled nimble model
bym_usual01_Cmodel <- compileNimble(bym_usual01_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
bym_usual01_conf <- configureMCMC(bym_usual01_model, monitors = c('beta0', 'beta', 'sigma2', 's', 'v'))

# (4) Do something
bym_usual01_conf$printSamplers()

# (5) Build MCMC object
bym_usual01_MCMC <- buildMCMC(bym_usual01_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
bym_usual01_CMCMC <- compileNimble(bym_usual01_MCMC, project = bym_usual01_Cmodel)  

# (7) Run the model
bym_usual01_runMCMC <- runMCMC(bym_usual01_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
bym_usual01_samples = rbind(bym_usual01_runMCMC$samples[[1]], bym_usual01_runMCMC$samples[[2]])

# Results ----------------------------------------------------------------------------------------

# (9) WAIC ---------------------------------------------------------------------------------------
bym_usual01_runMCMC$WAIC

# (10) Posterior summaries------------------------------------------------------------------------

################### betas : covariates

# Calculating the Beta means
means_betas_bym_usual01 <- apply(bym_usual01_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual01 <- t(apply(bym_usual01_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual01 <- t(matrix(c(means_betas_bym_usual01, CrI_betas_bym_usual01), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_bym_usual01)

################### S : estimates? per region

# Calculating the S means
means_s_bym_usual01 <- apply(bym_usual01_samples[ ,10:27],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_bym_usual01 <- t(apply(bym_usual01_samples[ ,10:27],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_bym_usual01 <- cbind(means_s_bym_usual01, CrI_s_bym_usual01) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_bym_usual01)

################### V : estimates? per region

# Calculating the V means
means_v_bym_usual01 <- apply(bym_usual01_samples[ ,29:ncol(bym_usual01_samples)],2, mean)

# Calculating the V 95% CrI 
CrI_v_bym_usual01 <- t(apply(bym_usual01_samples[ ,29:ncol(bym_usual01_samples)],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_v_bym_usual01 <- cbind(means_v_bym_usual01, CrI_v_bym_usual01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_v_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")


################## beta 0 

# Calculating the beta0 means
mean_beta0_bym_usual01 <- mean(bym_usual01_samples[ , "beta0"])

# Calculating the Beta 95% CrI 
CrI_beta0_bym_usual01 <- t(quantile(bym_usual01_samples[ , "beta0"], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_bym_usual01 <- cbind(mean_beta0_bym_usual01, CrI_beta0_bym_usual01) %>% as.data.frame()


# Renaming the columns
colnames(mean_CrI_beta0_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_bym_usual01)

# (11) Fitted values  ----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_bym_usual01 = matrix(NA, nrow=nrow(bym_usual01_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_bym_usual01[,i] = bym_usual01_samples[,"beta0"] + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% 
    t(bym_usual01_samples[,1:8]) + bym_usual01_samples[, 10+i-1] 
}

# Fitted values - distribution
fitted_usual_01_dist <- data.clean$Expected * exp(fitted_bym_usual01)

# Mean fitted SIR
fitted_SIR_bym_usual01 <- exp(apply(fitted_bym_usual01, 2, mean))

# Mean fitted Cases
fitted_usual_01 <- fitted_SIR_bym_usual01*data.clean$Expected

# 95% CrI SIR
fitted_usual_01_CrI_SIR <- t(exp(apply(fitted_bym_usual01, 2, function(x) quantile(x, probs=c(0.025, 0.975)))))

# 95% CrI Cases
fitted_usual_01_CrI <-  data.clean$Expected *fitted_usual_01_CrI_SIR

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_bym_usual01_df <- data.frame("Observed SIR"   =  round(data.clean$SIR, 2), 
                                "Fitted SIR"     =  round(fitted_SIR_bym_usual01,2), 
                                "Observed Cases" =  round(data.clean$Cases), 
                                "Fitted Cases" =  round(fitted_usual_01), 
                                "CrI LL"    =  round(fitted_usual_01_CrI[,1]),
                                "CrI UL"    =  round(fitted_usual_01_CrI[,2]))


# Top 6 rows
head(fitted_bym_usual01_df)

 
```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", bym_usual01_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual01_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual01_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual01_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual01_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual01_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual01_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual01_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual01_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual01_samples[,"sigma2"], type ="l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual01_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual01_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual01_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual01_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual01_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual01_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual01_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual01_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual01_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual01_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual01_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual01_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual01_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual01_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual01_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual01_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual01_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual01_samples[,"s[18]"], type = "l")
```

```{r Posterior density curve, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual01_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual01_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual01_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual01_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual01_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual01_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual01_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual01_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual01_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual01_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual01_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual01_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual01_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual01_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual01_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual01_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual01_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual01_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual01_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual01_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual01_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual01_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual01_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual01_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual01_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual01_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual01_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual01_samples[,"s[18]"]))
```

**Neighborhood structure 2: Distance-based neighbors (k = 3)**

```{r Nimble BYMCAR K3}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_bym_02 = list(N = nrow(data.clean),                # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.3),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.3,                             # Adjacency matrix
                       num = num.nb.3,                          # Number of neighbors per district
                       weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_bym_02 <- list(beta0 = 0,
                           beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                           sigma2 = 1, 
                           s = rnorm(num.nb.3),
                           v =  rep(0, nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
bym_usual02_model <- nimbleModel(code = usual_code_bym, constants = Consts_usual_bym_02, 
                                 data = outcome, inits = Inits_usual_bym_02)

# (2) Define the compiled nimble model
bym_usual02_Cmodel <- compileNimble(bym_usual02_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
bym_usual02_conf <- configureMCMC(bym_usual02_model, monitors = c('beta0', 'beta', 'sigma2', 's', 'v'))

# (4) Print samplers
bym_usual02_conf$printSamplers()

# (5) Build MCMC object
bym_usual02_MCMC <- buildMCMC(bym_usual02_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
bym_usual02_CMCMC <- compileNimble(bym_usual02_MCMC, project = bym_usual02_Cmodel)  

# (7) Run the model
bym_usual02_runMCMC <- runMCMC(bym_usual02_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
bym_usual02_samples = rbind(bym_usual02_runMCMC$samples[[1]], bym_usual02_runMCMC$samples[[2]])

# Results ----------------------------------------------------------------------------------------
=======
# Results ----------------------------------------------------------------------------------------

# (9) WAIC ---------------------------------------------------------------------------------------
bym_usual01_runMCMC$WAIC

# (10) Posterior summaries------------------------------------------------------------------------

################### betas : covariates

# Calculating the Beta means
means_betas_bym_usual01 <- apply(bym_usual01_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual01 <- t(apply(bym_usual01_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual01 <- t(matrix(c(means_betas_bym_usual01, CrI_betas_bym_usual01), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_bym_usual01) <- c("Mean", "95% CrI LL", "95% CrI UL")
>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf

# (9) WAIC ---------------------------------------------------------------------------------------
bym_usual02_runMCMC$WAIC

# (10) Posterior summaries------------------------------------------------------------------------

<<<<<<< HEAD
################### betas : covariates

# Calculating the Beta means
means_betas_bym_usual02 <- apply(bym_usual02_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual02 <- t(apply(bym_usual02_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual02 <- t(matrix(c(means_betas_bym_usual02, CrI_betas_bym_usual02), ncol=8, byrow=T)) %>% as.data.frame()


# Renaming the columns
colnames(mean_CrI_betas_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_bym_usual02)

################### S : estimates? per region

# Calculating the S means
means_s_bym_usual02 <- apply(bym_usual02_samples[ , 8:25],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_bym_usual02 <- t(apply(bym_usual02_samples[ , 8:25],2, function(x) quantile(x, probs=c(0.025,0.975))))


# Combining the means and CIs into a dataframe
mean_CrI_s_bym_usual02 <- cbind(means_s_bym_usual02, CrI_s_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_bym_usual02)

################### V : estimates? per region

# Calculating the V means
means_v_bym_usual02 <- apply(bym_usual02_samples[ ,27:ncol(bym_usual02_samples)],2, mean)

# Calculating the V 95% CrI 
CrI_v_bym_usual02 <- t(apply(bym_usual02_samples[ ,27:ncol(bym_usual02_samples)],2, function(x) quantile(x, probs=c(0.025,0.975))))


# Combining the means and CIs into a dataframe
mean_CrI_v_bym_usual02 <- cbind(means_v_bym_usual02, CrI_v_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_v_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_bym_usual02)

################## beta 0 

# Calculating the beta0 mean
mean_beta0_bym_usual02 <- mean(bym_usual02_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_bym_usual02 <- t(quantile(bym_usual02_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_bym_usual02 <- cbind(mean_beta0_bym_usual02, CrI_beta0_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_bym_usual02)

# (11) Fitted values  ----------------------------------------------------------------------------

# Creating matrix to store fitted values

fitted_bym_usual02 = matrix(NA, nrow=nrow(bym_usual02_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_bym_usual02[,i] = bym_usual02_samples[,"beta0"] 
                      + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(bym_usual02_samples[,1:8])
                      + bym_usual02_samples[, 7+i-1] 
                      + bym_usual02_samples[ , 9+i-1]

}

# Fitted values - distribution
fitted_bym_usual_02_dist <- data.clean$Expected * exp(fitted_bym_usual02)

# Mean fitted values
fitted_bym_usual_02 <- apply(fitted_bym_usual_02_dist, 2, mean)

# 95% CrI

fitted_bym_usual_02_CrI <- t(apply(fitted_bym_usual_02_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))


# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_bym_usual02_df <- cbind(fitted_bym_usual_02,fitted_bym_usual_02_CrI )

# Renaming columns

colnames(fitted_bym_usual02_df) <- c("fitted_mean_bym_usual02", "fitted_lower_bym_usual02" , "fitted_upper_bym_usual02")

# Top 6 rows
head(fitted_bym_usual02_df)

# Predicted vs observed cases
cbind(data.clean$Cases,fitted_bym_usual02_df)
```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", bym_usual02_samples[,"beta0"], type = "l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual02_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual02_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual02_samples[,"sigma2"], type ="l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual02_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual02_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual02_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual02_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual02_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual02_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual02_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual02_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual02_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual02_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual02_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual02_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual02_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual02_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual02_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual02_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual02_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual02_samples[,"s[18]"], type = "l")
```

```{r Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual02_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual02_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual02_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual02_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual02_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual02_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual02_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual02_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual02_samples[,"beta[8]"]))

# sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual02_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual02_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual02_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual02_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual02_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual02_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual02_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual02_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual02_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual02_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual02_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual02_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual02_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual02_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual02_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual02_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual02_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual02_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual02_samples[,"s[18]"]))
```

**Neighborhood structure 3: Distance-based neighbors (k = 5)**

=======
colnames(fitted_bym_usual01_df) <- c("fitted_mean_bym_usual01", "fitted_lower_bym_usual01" , "fitted_upper_bym_usual01")

# Top 6 rows
head(fitted_bym_usual01_df)

# Predicted vs observed cases
cbind(data.clean$Cases,fitted_bym_usual01_df)
```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)
plot(main ="Intercept", bym_usual01_samples[,"beta0"], type ="l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual01_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual01_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual01_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual01_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual01_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual01_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual01_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual01_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual01_samples[,"sigma2"], type ="l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual01_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual01_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual01_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual01_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual01_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual01_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual01_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual01_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual01_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual01_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual01_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual01_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual01_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual01_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual01_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual01_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual01_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual01_samples[,"s[18]"], type = "l")
```

```{r Posterior density curve, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual01_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual01_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual01_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual01_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual01_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual01_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual01_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual01_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual01_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual01_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual01_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual01_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual01_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual01_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual01_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual01_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual01_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual01_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual01_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual01_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual01_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual01_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual01_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual01_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual01_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual01_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual01_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual01_samples[,"s[18]"]))
```

**Neighborhood structure 2: Distance-based neighbors (k = 3)**

```{r Nimble BYMCAR K3}
# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_bym_02 = list(N = nrow(data.clean),                # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.3),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.3,                             # Adjacency matrix
                       num = num.nb.3,                          # Number of neighbors per district
                       weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_bym_02 <- list(beta0 = 0,
                           beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                           sigma2 = 1, 
                           s = rnorm(num.nb.3),
                           v =  rep(0, nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
bym_usual02_model <- nimbleModel(code = usual_code_bym, constants = Consts_usual_bym_02, 
                                 data = outcome, inits = Inits_usual_bym_02)

# (2) Define the compiled nimble model
bym_usual02_Cmodel <- compileNimble(bym_usual02_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
bym_usual02_conf <- configureMCMC(bym_usual02_model, monitors = c('beta0', 'beta', 'sigma2', 's', 'v'))

# (4) Print samplers
bym_usual02_conf$printSamplers()

# (5) Build MCMC object
bym_usual02_MCMC <- buildMCMC(bym_usual02_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
bym_usual02_CMCMC <- compileNimble(bym_usual02_MCMC, project = bym_usual02_Cmodel)  

# (7) Run the model
bym_usual02_runMCMC <- runMCMC(bym_usual02_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
bym_usual02_samples = rbind(bym_usual02_runMCMC$samples[[1]], bym_usual02_runMCMC$samples[[2]])

# Results ----------------------------------------------------------------------------------------

# (9) WAIC ---------------------------------------------------------------------------------------
bym_usual02_runMCMC$WAIC

# (10) Posterior summaries------------------------------------------------------------------------

################### betas : covariates

# Calculating the Beta means
means_betas_bym_usual02 <- apply(bym_usual02_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual02 <- t(apply(bym_usual02_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual02 <- t(matrix(c(means_betas_bym_usual02, CrI_betas_bym_usual02), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_bym_usual02)

################### S : estimates? per region

# Calculating the S means
means_s_bym_usual02 <- apply(bym_usual02_samples[ , 8:25],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_bym_usual02 <- t(apply(bym_usual02_samples[ , 8:25],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_bym_usual02 <- cbind(means_s_bym_usual02, CrI_s_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_bym_usual02)

################### V : estimates? per region

# Calculating the V means
means_v_bym_usual02 <- apply(bym_usual02_samples[ ,27:ncol(bym_usual02_samples)],2, mean)

# Calculating the V 95% CrI 
CrI_v_bym_usual02 <- t(apply(bym_usual02_samples[ ,27:ncol(bym_usual02_samples)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_v_bym_usual02 <- cbind(means_v_bym_usual02, CrI_v_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_v_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_bym_usual02)

################## beta 0 

# Calculating the beta0 mean
mean_beta0_bym_usual02 <- mean(bym_usual02_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_bym_usual02 <- t(quantile(bym_usual02_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_bym_usual02 <- cbind(mean_beta0_bym_usual02, CrI_beta0_bym_usual02) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_bym_usual02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_bym_usual02)

# (11) Fitted values  ----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_bym_usual02 = matrix(NA, nrow=nrow(bym_usual02_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_bym_usual02[,i] = bym_usual02_samples[,"beta0"] 
                      + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(bym_usual02_samples[,1:8])
                      + bym_usual02_samples[, 7+i-1] 
                      + bym_usual02_samples[ , 9+i-1]
}

# Fitted values - distribution
fitted_bym_usual_02_dist <- data.clean$Expected * exp(fitted_bym_usual02)

# Mean fitted values
fitted_bym_usual_02 <- apply(fitted_bym_usual_02_dist, 2, mean)

# 95% CrI
fitted_bym_usual_02_CrI <- t(apply(fitted_bym_usual_02_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_bym_usual02_df <- cbind(fitted_bym_usual_02,fitted_bym_usual_02_CrI )

# Renaming columns
colnames(fitted_bym_usual02_df) <- c("fitted_mean_bym_usual02", "fitted_lower_bym_usual02" , "fitted_upper_bym_usual02")

# Top 6 rows
head(fitted_bym_usual02_df)

# Predicted vs observed cases
cbind(data.clean$Cases,fitted_bym_usual02_df)
```

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", bym_usual02_samples[,"beta0"], type = "l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual02_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual02_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual02_samples[,"sigma2"], type ="l")

# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual02_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual02_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual02_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual02_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual02_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual02_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual02_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual02_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual02_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual02_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual02_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual02_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual02_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual02_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual02_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual02_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual02_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual02_samples[,"s[18]"], type = "l")
```

```{r Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual02_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual02_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual02_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual02_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual02_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual02_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual02_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual02_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual02_samples[,"beta[8]"]))

# sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual02_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual02_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual02_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual02_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual02_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual02_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual02_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual02_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual02_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual02_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual02_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual02_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual02_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual02_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual02_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual02_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual02_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual02_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual02_samples[,"s[18]"]))
```

**Neighborhood structure 3: Distance-based neighbors (k = 5)**

>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf
```{r Nimble BYMCAR K5}

# Defining the data that goes into the model ----------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_usual_bym_03 = list(N = nrow(data.clean),                # Number of areas
                       p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                       X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                       L = length(adj.5),                       # Edges (length of adj vector)
                       E = data.clean$Expected,                 # Expected cases
                       adj = adj.5,                             # Adjacency matrix
                       num = num.nb.5,                          # Number of neighbors per district
                       weights = rep(1, length(adj.5)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_usual_bym_03 <- list(beta0 = 0,
                           beta = rep(0, ncol(data.clean[5:ncol(data.clean)])), 
                           sigma2 = 1, 
                           s = rnorm(num.nb.5),
                           v =  rep(0, nrow(data.clean)))

# Defining model --------------------------------------------------------------------------------------------

# (1) Define the usual fixed prior model for nimble
bym_usual03_model <- nimbleModel(code = usual_code_bym, constants = Consts_usual_bym_03, 
                             data = outcome, inits = Inits_usual_bym_03)

# (2) Define the compiled nimble model
bym_usual03_Cmodel <- compileNimble(bym_usual03_model, showCompilerOutput = TRUE)      

# (3) Configure the MCMC chain
bym_usual03_conf <- configureMCMC(bym_usual03_model, monitors = c('beta0', 'beta', 'sigma2', 's', 'v'))

# (4) Print samplers
bym_usual03_conf$printSamplers()

# (5) Build MCMC object
bym_usual03_MCMC <- buildMCMC(bym_usual03_conf, enableWAIC = T) 

# (6) Compile model with MCMC object
bym_usual03_CMCMC <- compileNimble(bym_usual03_MCMC, project = bym_usual03_Cmodel)  

# (7) Run the model
bym_usual03_runMCMC <- runMCMC(bym_usual03_CMCMC, nburnin = 10000, niter = 200000, nchains = 2, thin = 25, WAIC = T)

# (8) Check convergence
bym_usual03_samples = rbind(bym_usual03_runMCMC$samples[[1]], bym_usual03_runMCMC$samples[[2]])

# Results ----------------------------------------------------------------------------------------

# (9) WAIC ---------------------------------------------------------------------------------------
bym_usual03_runMCMC$WAIC

# (10) Posterior summaries------------------------------------------------------------------------

################### betas : covariates

# Calculating the Beta means
means_betas_bym_usual03 <- apply(bym_usual03_samples[,1:8],2, mean)

# Calculating the Beta 95% CrI 
CrI_betas_bym_usual03 <- t(apply(bym_usual03_samples[ ,1:8],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_betas_bym_usual03 <- t(matrix(c(means_betas_bym_usual03, CrI_betas_bym_usual03), ncol=8, byrow=T)) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_betas_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_bym_usual03)

################### S : estimates? per region

# Calculating the S means
means_s_bym_usual03 <- apply(bym_usual03_samples[ , 8:25],2, mean)

# Calculating the Beta 95% CrI 
CrI_s_bym_usual03 <- t(apply(bym_usual03_samples[ , 8:25],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_s_bym_usual03 <- cbind(means_s_bym_usual03, CrI_s_bym_usual03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_s_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_bym_usual03)

################### V : estimates? per region

# Calculating the V means
means_v_bym_usual03 <- apply(bym_usual03_samples[ , 27:ncol(bym_usual03_samples)],2, mean)

# Calculating the V 95% CrI 
CrI_v_bym_usual03 <- t(apply(bym_usual03_samples[ , 27:ncol(bym_usual03_samples)],2, function(x) quantile(x, probs=c(0.025,0.975))))

# Combining the means and CIs into a dataframe
mean_CrI_v_bym_usual03 <- cbind(means_v_bym_usual03, CrI_v_bym_usual03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_v_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_v_bym_usual03)

################## beta 0 

# Calculating beta0 means
mean_beta0_bym_usual03 <- mean(bym_usual03_samples[ ,7])

# Calculating the beta0 95% CrI 
CrI_beta0_bym_usual03 <- t(quantile(bym_usual03_samples[ , 7], probs=c(0.025,0.975)))

# Combining the means and CIs into a dataframe
mean_CrI_beta0_bym_usual03 <- cbind(mean_beta0_bym_usual03, CrI_beta0_bym_usual03) %>% as.data.frame()

# Renaming the columns
colnames(mean_CrI_beta0_bym_usual03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_bym_usual03)

# (11) Fitted values -----------------------------------------------------------------------------

# Creating matrix to store fitted values
fitted_bym_usual03 = matrix(NA, nrow=nrow(bym_usual03_samples), ncol= nrow(data.clean))

# Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_bym_usual03[,i] = bym_usual03_samples[,"beta0"] 
                      + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(bym_usual03_samples[,1:8])
                      + bym_usual03_samples[, 7+i-1] 
                      + bym_usual03_samples[ , 9+i-1]
}

# Fitted values - distribution
fitted_bym_usual_03_dist <- data.clean$Expected * exp(fitted_bym_usual03)

# Mean fitted values
fitted_bym_usual_03 <- apply(fitted_bym_usual_03_dist, 2, mean)

# 95% CrI
fitted_bym_usual_03_CrI <- t(apply(fitted_bym_usual_03_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))

# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_bym_usual03_df <- cbind(fitted_bym_usual_03,fitted_bym_usual_03_CrI )

# Renaming columns
colnames(fitted_bym_usual03_df) <- c("fitted_mean_bym_usual03", "fitted_lower_bym_usual03" , "fitted_upper_bym_usual03")

# Top 6 rows
head(fitted_bym_usual03_df)

# Predicted vs observed cases
cbind(data.clean$Cases,fitted_bym_usual03_df)
```
<<<<<<< HEAD

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", bym_usual03_samples[,"beta0"], type = "l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual03_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual03_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual03_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual03_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual03_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual03_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual03_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual03_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual03_samples[,"sigma2"], type ="l")

=======

```{r MCMC chains, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", bym_usual03_samples[,"beta0"], type = "l")

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  bym_usual03_samples[,"beta[1]"] , type = "l")
plot(main = paste(names(data.clean[6])),  bym_usual03_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  bym_usual03_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  bym_usual03_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  bym_usual03_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), bym_usual03_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), bym_usual03_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), bym_usual03_samples[,"beta[8]"] , type = "l")

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", bym_usual03_samples[,"sigma2"], type ="l")

>>>>>>> 5c9933bf596de195c8a2e8404bcce912e20884cf
# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), bym_usual03_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), bym_usual03_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), bym_usual03_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), bym_usual03_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), bym_usual03_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), bym_usual03_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), bym_usual03_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), bym_usual03_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), bym_usual03_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), bym_usual03_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), bym_usual03_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), bym_usual03_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), bym_usual03_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), bym_usual03_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), bym_usual03_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), bym_usual03_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), bym_usual03_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), bym_usual03_samples[,"s[18]"], type = "l")
```

```{r Posterior density curves, echo = F}
# beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(bym_usual03_samples[,"beta0"]))

# betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(bym_usual03_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(bym_usual03_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(bym_usual03_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(bym_usual03_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(bym_usual03_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(bym_usual03_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(bym_usual03_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(bym_usual03_samples[,"beta[8]"]))

# sigma2
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(bym_usual03_samples[,"sigma2"]))

# Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(bym_usual03_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(bym_usual03_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(bym_usual03_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(bym_usual03_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(bym_usual03_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(bym_usual03_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(bym_usual03_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(bym_usual03_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(bym_usual03_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(bym_usual03_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(bym_usual03_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(bym_usual03_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(bym_usual03_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(bym_usual03_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(bym_usual03_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(bym_usual03_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(bym_usual03_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(bym_usual03_samples[,"s[18]"]))
```


## Ridge Regression

```{r usual Ridge code}
#########################################
#    Usual fixed priors model - RIDGE     # 
#########################################

# Defining the usual fixed priors model ------------------------------------------------------
ridge_code <- nimbleCode({ 
  
  # Defining our priors
  beta0 ~ dnorm(0, sd = 1000)
  
  for(j in 1:p){
    beta[j] ~ dnorm(0, sd=1*sqrt(1/lambda))  # Betas for the covariates
  }
  #nu ~ T(dt(0, 1, 1),0,) 
  #nu <- 1                  # Half-Cauchy priors for conditional std-dev & tuning param
  sigma ~ T(dt(0, 1, 1),0,) 
  lambda ~ T(dt(0, 1, 1),0,)

  
  # Defining transformed parameters
  tau2 <- 1 /(sigma^2)
  
  # CAR prior
  s[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau2, zero_mean = 1) #CAR prior
  
  # Defining likelihood
  for(i in 1:N) { 

    log(r[i]) <- beta0 + inprod(X[i, 1:p], beta[1:p]) + s[i]
    mu[i] <- E[i]*r[i]
    y[i] ~ dpois(mu[i])

  }
})

```

**Ridge : Neighborhood structure 1: Adjacent Neighbors**

```{r Ridge Adjacency}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge_01 = list(N = nrow(data.clean),                  # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                     L = length(adj),                       # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj,                             # Adjacency matrix
                     num = num.nb,                          # Number of neighbors per district
                     weights = rep(1, length(adj)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=500, beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=0.10, lambda=0.5, s=rnorm(nrow(data.clean)))

# Defining model ---------------------------------------------------------------------------------

# (1) Define ridge nimble model
ridge01_model = nimbleModel(code=ridge_code, constants=Consts_ridge_01, data=outcome,
                            inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge01_Cmodel=compileNimble(ridge01_model)

# (3) Configure the MCMC chain
ridge01_conf <- configureMCMC(ridge01_model, 
                              monitors = c('beta0',"beta", 'sigma', "lambda", 's'))

# (4) Do something
ridge01_conf$printSamplers()

# (5) Build MCMC object
ridge01_MCMC=buildMCMC(ridge01_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge01_CMCMC=compileNimble(ridge01_MCMC, project=ridge01_Cmodel)

# (7) Run the model
ridge01_runMCMC=runMCMC(ridge01_CMCMC, nburnin=50000, niter=200000, nchains=2, thin=10, WAIC=T)

# (8) Check convergence
ridge01_samples=rbind(ridge01_runMCMC$samples[[1]], ridge01_runMCMC$samples[[2]])
```

```{r}
# Plot the MCMC chains----------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", ridge01_samples[,"sigma"], type ="l")

#Beta0
plot(main ="Intercept", ridge01_samples[,"beta0"], type = "l")

# lambda
plot(main ="Lambda", ridge01_samples[,"lambda"], type = "l")

# nu
#plot(main ="Nu", ridge01_samples[,"nu"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  ridge01_samples[,"beta[1]"] , type = "l") # Why are all beta's = 1
plot(main = paste(names(data.clean[6])),  ridge01_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge01_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge01_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge01_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge01_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge01_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge01_samples[,"beta[8]"] , type = "l")
plot(main = paste(names(data.clean[13])), ridge01_samples[,"beta[9]"] , type = "l")
plot(main = paste(names(data.clean[14])),ridge01_samples[,"beta[10]"] , type = "l")
plot(main = paste(names(data.clean[15])),ridge01_samples[,"beta[11]"] , type = "l")
plot(main = paste(names(data.clean[16])),ridge01_samples[,"beta[12]"] , type = "l")
plot(main = paste(names(data.clean[17])),ridge01_samples[,"beta[13]"] , type = "l")
plot(main = paste(names(data.clean[18])),ridge01_samples[,"beta[14]"] , type = "l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge01_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge01_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge01_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge01_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge01_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge01_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge01_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge01_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge01_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge01_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge01_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge01_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge01_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge01_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge01_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge01_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge01_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge01_samples[,"s[18]"], type = "l")







# Plot the density curves for posterior -------------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge01_samples[,"sigma2"]))

#Beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge01_samples[,"beta0"]))

#Lambda
plot(main ="Lambda", density(ridge01_samples[,"lambda"]))

# nu
#plot(main ="Nu", density(ridge02_samples[,"nu"]))

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(ridge01_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge01_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge01_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge01_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge01_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge01_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge01_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge01_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(ridge01_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(ridge01_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(ridge01_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(ridge01_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(ridge01_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(ridge01_samples[,"beta[14]"]))


#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge01_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge01_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge01_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge01_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge01_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge01_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge01_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge01_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge01_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge01_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge01_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge01_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge01_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge01_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge01_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge01_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge01_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge01_samples[,"s[18]"]))










# (9) WAIC ---------
ridge01_runMCMC$WAIC




# (10) Posterior summaries: Means and CrI  ---------

#Betas
#Calculating the Beta means
means_betas_ridge01 <- apply(ridge01_samples[,1:6],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge01 <- t(apply(ridge01_samples[ ,1:6],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge01 <- t(matrix(c(means_betas_ridge01, CrI_betas_ridge01), ncol=14, byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge01)

################### S : estimates? per region

#Calculating the S means
means_s_ridge01 <- apply(ridge01_samples[ ,8:25],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge01 <- t(apply(ridge01_samples[ ,8:25],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge01 <- cbind(means_s_ridge01, CrI_s_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge01)


################### Sigma

#Calculating the sigma means
means_sigma_ridge01 <- mean(ridge01_samples[ ,26])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge01 <- t(quantile(ridge01_samples[ ,26], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge01 <- cbind(means_sigma_ridge01, CrI_sigma_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge01)



################## beta 0 

mean_beta0_ridge01 <- mean(ridge01_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge01 <- t(quantile(ridge01_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge01 <- cbind(mean_beta0_ridge01, CrI_beta0_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge01)


################## Lambda

mean_beta0_ridge01 <- mean(ridge01_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge01 <- t(quantile(ridge01_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge01 <- cbind(mean_beta0_ridge01, CrI_beta0_ridge01) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge01) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge01)


# (11) Fitted values  ---------

#Creating matrix to store fitted values
fitted_ridge01 = matrix(NA, nrow=nrow(ridge01_samples), ncol= nrow(data.clean))

#Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge01[,i] = ridge01_samples[,"beta0"] 
                      + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(ridge01_samples[,1:5])
                      + ridge01_samples[, 7+i-1] 

}

# Fitted values - distribution
fitted_bym_usual_03_dist <- data.clean$Expected * exp(fitted_ridge01)


# Mean fitted values
fitted_bym_usual_03 <- apply(fitted_bym_usual_03_dist, 2, mean)

# 95% CrI
fitted_bym_usual_03_CrI <- t(apply(fitted_bym_usual_03_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))


# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge01_df <- cbind(fitted_bym_usual_03,fitted_bym_usual_03_CrI )



# Renaming columns
colnames(fitted_ridge01_df) <- c("fitted_mean_ridge01", "fitted_lower_ridge01" , "fitted_upper_ridge01")

#Top 6 rows
head(fitted_ridge01_df)

#Predicted vs observed cases
cbind(data.clean$Cases,fitted_ridge01_df)




```

**Ridge: Neighborhood structure 2: Distance-based neighbors (k = 3)**

```{r Ridge K = 3 }
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge_02 = list(N = nrow(data.clean),                  # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                     L = length(adj.3),                       # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj.3,                             # Adjacency matrix
                     num = num.nb.3,                          # Number of neighbors per district
                     weights = rep(1, length(adj.3)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=1, beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1, nu=1, lambda=0.5, s=rnorm(nrow(data.clean)))




# Defining model --------------------------------------------------------------------------------------------

# (1) Define ridge nimble model
ridge02_model=nimbleModel(code=ridge_code, constants=Consts_ridge_02, data=outcome, inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge02_Cmodel=compileNimble(ridge02_model)

# (3) Configure the MCMC chain
ridge02_conf <- configureMCMC(ridge02_model, 
                              monitors = c('beta0',"beta",'nu' ,'sigma', "lambda", 's'))

# (4) Do something
ridge02_conf$printSamplers()

# (5) Build MCMC object
ridge02_MCMC=buildMCMC(ridge02_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge02_CMCMC=compileNimble(ridge02_MCMC, project=ridge02_Cmodel)

# (7) Run the model
ridge02_runMCMC=runMCMC(ridge02_CMCMC, nburnin=50000, niter=200000, nchains=2, thin=10, WAIC=T)

# (8) Check convergence
ridge02_samples=rbind(ridge02_runMCMC$samples[[1]], ridge02_runMCMC$samples[[2]])




# Plot the MCMC chains----------


#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", ridge02_samples[,"sigma"], type ="l")

#Beta0
plot(main ="Intercept", ridge02_samples[,"beta0"], type = "l")

# lambda
plot(main ="Lambda", ridge02_samples[,"lambda"], type = "l")

# nu
plot(main ="Nu", ridge02_samples[,"nu"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  ridge02_samples[,"beta[1]"] , type = "l") # Why are all beta's = 1
plot(main = paste(names(data.clean[6])),  ridge02_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge02_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge02_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge02_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge02_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge02_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge02_samples[,"beta[8]"] , type = "l")
plot(main = paste(names(data.clean[13])), ridge02_samples[,"beta[9]"] , type = "l")
plot(main = paste(names(data.clean[14])),ridge02_samples[,"beta[10]"] , type = "l")
plot(main = paste(names(data.clean[15])),ridge02_samples[,"beta[11]"] , type = "l")
plot(main = paste(names(data.clean[16])),ridge02_samples[,"beta[12]"] , type = "l")
plot(main = paste(names(data.clean[17])),ridge02_samples[,"beta[13]"] , type = "l")
plot(main = paste(names(data.clean[18])),ridge02_samples[,"beta[14]"] , type = "l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge02_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge02_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge02_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge02_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge02_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge02_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge02_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge02_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge02_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge02_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge02_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge02_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge02_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge02_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge02_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge02_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge02_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge02_samples[,"s[18]"], type = "l")







# Plot the density curves for posterior -------------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge02_samples[,"sigma2"]))

#Beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge02_samples[,"beta0"]))

#Lambda
plot(main ="Lambda", density(ridge02_samples[,"lambda"]))

# nu
plot(main ="Nu", density(ridge02_samples[,"nu"]))

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(ridge02_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge02_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge02_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge02_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge02_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge02_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge02_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge02_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(ridge02_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(ridge02_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(ridge02_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(ridge02_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(ridge02_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(ridge02_samples[,"beta[14]"]))


#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge02_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge02_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge02_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge02_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge02_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge02_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge02_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge02_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge02_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge02_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge02_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge02_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge02_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge02_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge02_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge02_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge02_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge02_samples[,"s[18]"]))






# (9) WAIC ---------
ridge02_runMCMC$WAIC





# (10) Posterior summaries: Means and CrI  ---------

#Betas
#Calculating the Beta means
means_betas_ridge02 <- apply(ridge02_samples[,1:6],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge02 <- t(apply(ridge02_samples[ ,1:6],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge02 <- t(matrix(c(means_betas_ridge02, CrI_betas_ridge02), ncol=14, byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge02)

################### S : estimates? per region

#Calculating the S means
means_s_ridge02 <- apply(ridge02_samples[ ,8:25],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge02 <- t(apply(ridge02_samples[ ,8:25],2, function(x) quantile(x, probs=c(0.025,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge02 <- cbind(means_s_ridge02, CrI_s_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge02)


################### Sigma

#Calculating the sigma means
means_sigma_ridge02 <- mean(ridge02_samples[ ,26])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge02 <- t(quantile(ridge02_samples[ ,26], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge02 <- cbind(means_sigma_ridge02, CrI_sigma_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge02)



################## beta 0 

mean_beta0_ridge02 <- mean(ridge02_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge02 <- t(quantile(ridge02_samples[ , "beta0"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge02 <- cbind(mean_beta0_ridge02, CrI_beta0_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge02)


################## Lambda

mean_beta0_ridge02 <- mean(ridge02_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge02 <- t(quantile(ridge02_samples[ , "lambda"], probs=c(0.025,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge02 <- cbind(mean_beta0_ridge02, CrI_beta0_ridge02) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge02) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge02)




# (11) Fitted values  ---------

#Creating matrix to store fitted values
fitted_ridge02 = matrix(NA, nrow=nrow(ridge02_samples), ncol= nrow(data.clean))

#Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge02[,i] = ridge02_samples[,"beta0"] 
                      + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(ridge02_samples[,1:5])
                      + ridge02_samples[, 7+i-1] 

}

# Fitted values - distribution
fitted_bym_usual_03_dist <- data.clean$Expected * exp(fitted_ridge02)


# Mean fitted values
fitted_bym_usual_03 <- apply(fitted_bym_usual_03_dist, 2, mean)

# 95% CrI
fitted_bym_usual_03_CrI <- t(apply(fitted_bym_usual_03_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))


# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge02_df <- cbind(fitted_bym_usual_03,fitted_bym_usual_03_CrI )


# Renaming columns
colnames(fitted_ridge02_df) <- c("fitted_mean_ridge02", "fitted_lower_ridge02" , "fitted_upper_ridge02")

#Top 6 rows
head(fitted_ridge02_df)

#Predicted vs observed cases
cbind(data.clean$Cases,fitted_ridge02_df)




```

**Ridge: Neighborhood structure 3: Distance-based neighbors (k = 5)**

```{r Ridge K = 5}
# Model -> Compile model -> build MCMC object -> Compile MCMC object -> run MCMC

# Constants and initial values --------------------------------------------------------------------------

# (1) Define constants that go into CAR prior into a list
Consts_ridge_03 = list(N = nrow(data.clean),                  # Number of areas
                     p = ncol(data.clean[5:ncol(data.clean)]),            # Number of covariates
                     X = as.matrix(data.clean[, c(5:ncol(data.clean))]),  # Matrix of covariates
                     L = length(adj.5),                       # Edges (length of adj vector)
                     E = data.clean$Expected,
                     adj = adj.5,                             # Adjacency matrix
                     num = num.nb.5,                          # Number of neighbors per district
                     weights = rep(1, length(adj.5)))         # Giving weight of 1 for neighbors

# (2) Define dependent variable (outcome)
outcome <- list(y = data.clean$Cases) # Observed cases

# (3) Define initial values for the MCMC chain
Inits_ridge <- list(beta0=1, beta=rep(0, ncol(data.clean[5:ncol(data.clean)])),
                    sigma=1, nu=1, lambda=0.5, s=rnorm(nrow(data.clean)))




# Defining model --------------------------------------------------------------------------------------------

# (1) Define ridge nimble model
ridge03_model=nimbleModel(code=ridge_code, constants=Consts_ridge_03, data=outcome, inits=Inits_ridge)

# (2) Compile ridge model for nimble
ridge03_Cmodel=compileNimble(ridge03_model)

# (3) Configure the MCMC chain
ridge03_conf <- configureMCMC(ridge03_model, 
                              monitors = c('beta0',"beta",'nu' ,'sigma', "lambda", 's'))

# (4) Do something
ridge03_conf$printSamplers()

# (5) Build MCMC object
ridge03_MCMC=buildMCMC(ridge03_conf, enableWAIC=T)

# (6) Compile model with MCMC object
ridge03_CMCMC=compileNimble(ridge03_MCMC, project=ridge03_Cmodel)

# (7) Run the model
ridge03_runMCMC=runMCMC(ridge03_CMCMC, nburnin=50000, niter=200000, nchains=2, thin=10, WAIC=T)

# (8) Check convergence
ridge03_samples=rbind(ridge03_runMCMC$samples[[1]], ridge03_runMCMC$samples[[2]])





# Plot the MCMC chains----------


#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", ridge03_samples[,"sigma"], type ="l")

#Beta0
plot(main ="Intercept", ridge03_samples[,"beta0"], type = "l")

# lambda
plot(main ="Lambda", ridge03_samples[,"lambda"], type = "l")

# nu
plot(main ="Nu", ridge03_samples[,"nu"], type = "l")

# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),  ridge03_samples[,"beta[1]"] , type = "l") # Why are all beta's = 1
plot(main = paste(names(data.clean[6])),  ridge03_samples[,"beta[2]"] , type = "l")
plot(main = paste(names(data.clean[7])),  ridge03_samples[,"beta[3]"] , type = "l")
plot(main = paste(names(data.clean[8])),  ridge03_samples[,"beta[4]"] , type = "l")
plot(main = paste(names(data.clean[9])),  ridge03_samples[,"beta[5]"] , type = "l")
plot(main = paste(names(data.clean[10])), ridge03_samples[,"beta[6]"] , type = "l")
plot(main = paste(names(data.clean[11])), ridge03_samples[,"beta[7]"] , type = "l")
plot(main = paste(names(data.clean[12])), ridge03_samples[,"beta[8]"] , type = "l")
plot(main = paste(names(data.clean[13])), ridge03_samples[,"beta[9]"] , type = "l")
plot(main = paste(names(data.clean[14])),ridge03_samples[,"beta[10]"] , type = "l")
plot(main = paste(names(data.clean[15])),ridge03_samples[,"beta[11]"] , type = "l")
plot(main = paste(names(data.clean[16])),ridge03_samples[,"beta[12]"] , type = "l")
plot(main = paste(names(data.clean[17])),ridge03_samples[,"beta[13]"] , type = "l")
plot(main = paste(names(data.clean[18])),ridge03_samples[,"beta[14]"] , type = "l")


# Spatial effects for each region  
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), ridge03_samples[,"s[1]"]  , type = "l") 
plot(main = paste(data.clean$District[2]), ridge03_samples[,"s[2]"]  , type = "l")
plot(main = paste(data.clean$District[3]), ridge03_samples[,"s[3]"]  , type = "l")
plot(main = paste(data.clean$District[4]), ridge03_samples[,"s[4]"]  , type = "l")
plot(main = paste(data.clean$District[5]), ridge03_samples[,"s[5]"]  , type = "l")
plot(main = paste(data.clean$District[6]), ridge03_samples[,"s[6]"]  , type = "l")
plot(main = paste(data.clean$District[7]), ridge03_samples[,"s[7]"]  , type = "l")
plot(main = paste(data.clean$District[8]), ridge03_samples[,"s[8]"]  , type = "l")
plot(main = paste(data.clean$District[9]), ridge03_samples[,"s[9]"]  , type = "l")
plot(main = paste(data.clean$District[10]), ridge03_samples[,"s[10]"], type = "l")
plot(main = paste(data.clean$District[11]), ridge03_samples[,"s[11]"], type = "l")
plot(main = paste(data.clean$District[12]), ridge03_samples[,"s[12]"], type = "l")
plot(main = paste(data.clean$District[13]), ridge03_samples[,"s[13]"], type = "l")
plot(main = paste(data.clean$District[14]), ridge03_samples[,"s[14]"], type = "l")
plot(main = paste(data.clean$District[15]), ridge03_samples[,"s[15]"], type = "l")
plot(main = paste(data.clean$District[16]), ridge03_samples[,"s[16]"], type = "l")
plot(main = paste(data.clean$District[17]), ridge03_samples[,"s[17]"], type = "l")
plot(main = paste(data.clean$District[18]), ridge03_samples[,"s[18]"], type = "l")








# Plot the density curves for posterior -------------

#sigma squared
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Sigma Squared", density(ridge03_samples[,"sigma2"]))

#Beta0
par(mfrow=c(1,1), mar=c(2,4.5,2.1,1)+0.1)
plot(main ="Intercept", density(ridge03_samples[,"beta0"]))

#Lambda
plot(main ="Lambda", density(ridge03_samples[,"lambda"]))

#Nu
plot(main ="Nu", density(ridge03_samples[,"nu"]))


# Betas (Covariates) - log scale
par(mfrow=c(4,4), mar=c(2,4.5,2.1,1)+0.1)
plot(main = paste(names(data.clean[5])),density(ridge03_samples[,"beta[1]"])) 
plot(main = paste(names(data.clean[6])),density(ridge03_samples[,"beta[2]"]))
plot(main = paste(names(data.clean[7])),density(ridge03_samples[,"beta[3]"]))
plot(main = paste(names(data.clean[8])),density(ridge03_samples[,"beta[4]"]))
plot(main = paste(names(data.clean[9])),density(ridge03_samples[,"beta[5]"]))
plot(main = paste(names(data.clean[10])),density(ridge03_samples[,"beta[6]"]))
plot(main = paste(names(data.clean[11])),density(ridge03_samples[,"beta[7]"]))
plot(main = paste(names(data.clean[12])),density(ridge03_samples[,"beta[8]"]))
plot(main = paste(names(data.clean[13])),density(ridge03_samples[,"beta[9]"]))
plot(main = paste(names(data.clean[14])),density(ridge03_samples[,"beta[10]"]))
plot(main = paste(names(data.clean[15])),density(ridge03_samples[,"beta[11]"]))
plot(main = paste(names(data.clean[16])),density(ridge03_samples[,"beta[12]"]))
plot(main = paste(names(data.clean[17])),density(ridge03_samples[,"beta[13]"]))
plot(main = paste(names(data.clean[18])),density(ridge03_samples[,"beta[14]"]))


#Spatial effects for each region 
par(mfrow=c(4,5), mar=c(2,3,2.1,1)+0.1)
plot(main = paste(data.clean$District[1]), density(ridge03_samples[,"s[1]"])) 
plot(main = paste(data.clean$District[2]), density(ridge03_samples[,"s[2]"]))
plot(main = paste(data.clean$District[3]), density(ridge03_samples[,"s[3]"]))
plot(main = paste(data.clean$District[4]), density(ridge03_samples[,"s[4]"]))
plot(main = paste(data.clean$District[5]), density(ridge03_samples[,"s[5]"]))
plot(main = paste(data.clean$District[6]), density(ridge03_samples[,"s[6]"]))
plot(main = paste(data.clean$District[7]), density(ridge03_samples[,"s[7]"]))
plot(main = paste(data.clean$District[8]), density(ridge03_samples[,"s[8]"]))
plot(main = paste(data.clean$District[9]), density(ridge03_samples[,"s[9]"]))
plot(main = paste(data.clean$District[10]), density(ridge03_samples[,"s[10]"]))
plot(main = paste(data.clean$District[11]), density(ridge03_samples[,"s[11]"]))
plot(main = paste(data.clean$District[12]), density(ridge03_samples[,"s[12]"]))
plot(main = paste(data.clean$District[13]), density(ridge03_samples[,"s[13]"]))
plot(main = paste(data.clean$District[14]), density(ridge03_samples[,"s[14]"]))
plot(main = paste(data.clean$District[15]), density(ridge03_samples[,"s[15]"]))
plot(main = paste(data.clean$District[16]), density(ridge03_samples[,"s[16]"]))
plot(main = paste(data.clean$District[17]), density(ridge03_samples[,"s[17]"]))
plot(main = paste(data.clean$District[18]), density(ridge03_samples[,"s[18]"]))






# (9) WAIC ---------
ridge03_runMCMC$WAIC






# (10) Posterior summaries: Means and CrI  ---------

#Betas
#Calculating the Beta means
means_betas_ridge03 <- apply(ridge03_samples[,1:6],2, mean)

#Calculating the Beta 95% CrI 
CrI_betas_ridge03 <- t(apply(ridge03_samples[ ,1:6],2, function(x) quantile(x, probs=c(0.035,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_betas_ridge03 <- t(matrix(c(means_betas_ridge03, CrI_betas_ridge03), ncol=14, byrow=T)) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_betas_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_betas_ridge03)

################### S : estimates? per region

#Calculating the S means
means_s_ridge03 <- apply(ridge03_samples[ ,8:25],2, mean)

#Calculating the Beta 95% CrI 
CrI_s_ridge03 <- t(apply(ridge03_samples[ ,8:25],2, function(x) quantile(x, probs=c(0.035,0.975))))

#Combining the means and CIs into a dataframe
mean_CrI_s_ridge03 <- cbind(means_s_ridge03, CrI_s_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_s_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_s_ridge03)


################### Sigma

#Calculating the sigma means
means_sigma_ridge03 <- mean(ridge03_samples[ ,26])

#Calculating the Beta 95% CrI 
CrI_sigma_ridge03 <- t(quantile(ridge03_samples[ ,26], probs=c(0.035,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_sigma_ridge03 <- cbind(means_sigma_ridge03, CrI_sigma_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_sigma_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Consigmaerting means and CrIs from log to regular scale
exp(mean_CrI_sigma_ridge03)



################## beta 0 

mean_beta0_ridge03 <- mean(ridge03_samples[ ,"beta0"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge03 <- t(quantile(ridge03_samples[ , "beta0"], probs=c(0.035,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge03 <- cbind(mean_beta0_ridge03, CrI_beta0_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge03)


################## Lambda

mean_beta0_ridge03 <- mean(ridge03_samples[ ,"lambda"])

#Calculating the Beta 95% CrI 
CrI_beta0_ridge03 <- t(quantile(ridge03_samples[ , "lambda"], probs=c(0.035,0.975)))

#Combining the means and CIs into a dataframe
mean_CrI_beta0_ridge03 <- cbind(mean_beta0_ridge03, CrI_beta0_ridge03) %>% as.data.frame()

#Renaming the columns
colnames(mean_CrI_beta0_ridge03) <- c("Mean", "95% CrI LL", "95% CrI UL")

# Converting means and CrIs from log to regular scale
exp(mean_CrI_beta0_ridge03)





# (11) Fitted values  ---------

#Creating matrix to store fitted values
fitted_ridge03 = matrix(NA, nrow=nrow(ridge03_samples), ncol= nrow(data.clean))

#Loop to generate fitted values: log(ri)
for(i in 1:nrow(data.clean)){
  fitted_ridge03[,i] = ridge03_samples[,"beta0"] 
                      + as.matrix(data.clean[i,5:ncol(data.clean)]) %*% t(ridge03_samples[,1:5])
                      + ridge03_samples[, 7+i-1] 

}

# Fitted values - distribution
fitted_bym_usual_03_dist <- data.clean$Expected * exp(fitted_ridge03)

# Mean fitted values
fitted_bym_usual_03 <- apply(fitted_bym_usual_03_dist, 2, mean)

# 95% CrI
fitted_bym_usual_03_CrI <- t(apply(fitted_bym_usual_03_dist, 2, function(x) quantile(x, probs=c(0.025, 0.975))))


# Creating Dataframe to store fitted values and quantiles in regular svale
fitted_ridge03_df <- cbind(fitted_bym_usual_03,fitted_bym_usual_03_CrI )

# Renaming columns
colnames(fitted_ridge03_df) <- c("fitted_mean_ridge03", "fitted_lower_ridge03" , "fitted_upper_ridge03")

#Top 6 rows
head(fitted_ridge03_df)

#Predicted vs observed cases
cbind(data.clean$Cases,fitted_ridge03_df)




```


# Summary of Inferential Results - iCAR, BYMCAR, Ridge (3 pages)

```{r WAICs}
#WAIC by ICAR model
WAIC.iCAR <- cbind(Adjescent= usual01_runMCMC$WAIC, K3= usual02_runMCMC$WAIC,K5= usual03_runMCMC$WAIC)
WAIC.iCAR

#WAIC by BYM CAR model
WAIC.bymCAR <- cbind(Adjescent= bym_usual01_runMCMC$WAIC, K3= bym_usual02_runMCMC$WAIC,K5= bym_usual03_runMCMC$WAIC)
WAIC.bymCAR

#WAIC by Ridgemodel
WAIC.Ridge <- cbind(Adjescent = ridge01_runMCMC$WAIC,  K3= ridge02_runMCMC$WAIC,  K5 = ridge03_runMCMC$WAIC)
WAIC.Ridge
```

# Conclusion (1 page)

# Appendix

# Archive

```{r Boxplots by district and region, echo = F}
#Plots of variables by Region

# # create graphing function
# HK.district.boxplots <- function(df, na.rm = TRUE, ...){
#   
#   # create for loop to produce ggplot2 graphs 
#   for (i in seq_along(names(df[,3:ncol(df)]))) { 
#     
#     # create plot for each district in df 
#     plot <- 
#       ggplot(df,
#              aes(Region, df[,i],group = District, colour = Region)) + 
#       
#       geom_boxplot(size=6, notch = T) +
#       
#       theme_pander() +
#       theme(legend.position="none") + 
#       labs(y="Value")+
#       
#       ggtitle(paste(names(Covariates[i]), '\n', 
#                     "By Region \n",
#                     sep=''))
# 
#     # print plots to screen
#     print(plot)
#   }
# }
# 
# # run graphing function on long df
# HK.district.boxplots(Covariates)
```

```{r Boxplot by region, echo = F}
# create graphing function
# HK.region.boxplots <- function(df, na.rm = TRUE, ...){
#   
#   # create for loop to produce ggplot2 graphs 
#   for (i in seq_along(names(df[,3:ncol(df)]))) { 
#     
#     # create plot for each district in df 
#     plot <- 
#       ggplot(df,
#              aes( x=Region, y=df[,i], fill = Region)) + 
#       
#       geom_boxplot(size=1, notch = F) +
#       
#       theme_pander() +
#       theme(legend.position="none") + 
#       labs(y="Value")
#       
#       ggtitle(paste(names(covariates[i]), '\n', 
#                     "By Region \n",
#                     sep=''))
# 
#     # print plots to screen
#     print(plot)
#   }
# }
# 
# # run graphing function on long df
# HK.region.boxplots(covariates)
```

```{r Histograms by district, echo = F}

# # create graphing function
# HK.histogram <- function(df, na.rm = TRUE, ...){
#   
#   # create for loop to produce ggplot2 graphs 
#   for (i in seq_along(names(df[,3:ncol(df)]))) { 
#     
#     # create plot for each district in df 
#     plot <- ggplot(df, aes(df[,i])) + 
#       geom_bar(position="dodge", aes(fill=Region, size=2) )+
#       #facet_wrap(~Region)
#       theme_pander() +
#       theme(legend.position="none") + 
#       labs(y="Value", x= paste(names(Covariates[i])))+
#       
#       ggtitle(paste(names(Covariates[i]), '\n', 
#                     "By Region \n",
#                     sep=''))
#     # print plots to screen
#     print(plot)
#   }
# }
# 
# # run graphing function on long df
# HK.histogram(Covariates)
```

```{r Histograms of new transformed variables, echo = F}
# # Histogram of SIR and new covariates ----------------------------------------------------------
# sir <-     ggplot(data = data, aes(SIR)) + 
#               geom_histogram() + ylab("Frequency")
# age1 <-    ggplot(data = data, aes(Prop_0.24)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Prop of 0-24 yrs old")
# age2 <-    ggplot(data = data, aes(Prop_25.64)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Prop of 25-64 yrs old")
# age3 <-    ggplot(data = data, aes(Prop_65)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Prop of 65+ yrs old")
# income <-  ggplot(data = data, aes(Log_income)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Log(Monthly income)")
# postsec <- ggplot(data = data, aes(Log_postsec)) + 
#               geom_histogram() + ylab("Frequency") + xlab("Log(Prop with Post-Secondary Education)")
# 
# grid.arrange(sir, age1, age2, age3, income, postsec, ncol = 3)
```

```{r Map of 0-24 year olds, echo = F}
# Plot of Population of 0-14 years old ------------------------------------------------------------------
# plotg =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Prop0_14)) + 
#   ggtitle("Proportion of 0-14 years old") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)
```

```{r Map unused, echo = F}
# Plot of number of households ----------------------------------------------------------------------
# plot.house = 
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Num_household)) + 
#   ggtitle("Number of households") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of male population ------------------------------------------------------------------------
# plot.male = 
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = PropMale)) + 
#   ggtitle("Proportion of males") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of Number of housing units ----------------------------------------------------------------------
# plotk =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Housing)) + 
#   ggtitle("Number of Households") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of proportion of secondary education and higher -------------------------------------------
# plotj =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = SecEduc)) + 
#   ggtitle("Proportion with Secondary Education and higher") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)

# Plot of Income ----------------------------------------------------------------------------------------
# plotn =
#   ggplot(data = shp_HK.df, aes(x = long, y = lat, group = group), colour = "black", fill = NA) +
#   geom_polygon(data = shp_HK.df, aes(fill = Income)) + 
#   ggtitle("Monthly Income") +
#   scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
#   theme(legend.title = element_blank(),
#         legend.justification=c(1,0), 
#         legend.position=c(1,0),
#         plot.title = element_text(hjust = 0.5),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid = element_blank(),
#         axis.title = element_blank(), 
#         panel.background = element_blank()) +
#     coord_fixed(1.3)
```

```{r Poisson regression}
# Poisson regression
#poi.fit <- glm(Cases ~ Pop_density + Prop_labor + Prop_0.24 + Prop_25.64 + Prop_65 + Prop_female +  Log_postsec +  beds_per_hosp  + household_poverty_rate + offset(log(Expected)), data = data.clean, family = poisson(link="log"))
```

```{r Building number of neighbors and adjacency list fo nimble, echo = F}
# Number of neighbors per district -------------------------------------------------

# 1) Having contiguous boundary point
# num.nb <- c()
# for(i in 1:n){
#   num.nb[i] <- sum(HK.nbmat.adj[i,])
# }

# 2) Having 3 nearest neighbors
# num.nb.3 <- c()
# for(i in 1:n){
#   num.nb.3[i] <- sum(HK.nbmat.3[i,])
# }

# 3) Having 5 nearest neighbors
# num.nb.5 <- c()
# for(i in 1:n){
#   num.nb.5[i] <- sum(HK.nbmat.5[i,])
# }

# Adjacency vectors -----------------------------------------------------------------

# 1) Having contiguous boundary point
## list of regions with their respective contiguous neighborhoods
#adj <- list()
#for(i in 1:n){
#  adj[[i]] <- c(which(HK.nbmat.adj[i,] == 1))
#}

# 2) Having 3 nearest neighbors  ------- This function leads to an error in the nimble code
#adj.3 <- c()
#adj.3 <- which(HK.nbmat.adj[1,] == 1)
#for(i in 2:n){
#  adj.3 <- c(adj.3, c(which(HK.nbmat.3[i,] == 1)))
#}

 #3) Having 5 nearest neighbors ------- This function leads to an error in the nimble code
#adj.5 <- c()
#adj.5 <- which(HK.nbmat.adj[1,] == 1)
#for(i in 2:n){
#  adj.5 <- c(adj.5, c(which(HK.nbmat.5[i,] == 1)))
#}
```

